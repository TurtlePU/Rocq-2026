(** * Индукция: доказательства по индукции *)

(* ################################################################# *)
(** * Раздельная компиляция *)

(** Перед началом работы над этой главой, нам нужно импортировать все наши
    определения из предыдущей части: *)

From Lectures Require Export Basics.

(** Чтобы команда [Require] сработала, Rocq нужно найти скомпилированную
    версию предыдущей главы ([Basics.v]). Эта скомпилированная версия называется
    [Basics.vo] и аналогична [.class]-файлам, скомпилированным
    из [.java]-исходников, а также [.o]-файлам, скомпилированных из исходников
    на C.

    Чтобы скомпилировать [Basics.v] и получить [Basics.vo], сперва убедитесь,
    что файлы [Basics.v], [Induction.v] и [_CoqProject] находятся в текущей
    директории.

    Файл [_CoqProject] должен содержать только следующую строчку:

      -Q . Lectures

    Эта команда связывает текущую директорию ("[.]", которая содержит
    [Basics.v], [Induction.v] и т.д.) с префиксом (т.н. "логической
    директорией") "[Lectures]". Proof General, CoqIDE и VSCoq читают
    [_CoqProject] автоматически, чтобы понять, где искать [Basics.vo],
    соответствующий библиотеке [Lectures.Basics].

    При условии, что все файлы на месте, есть множество способов собрать
    [Basics.vo], как с помощью IDE, так и просто из командной строки.
    С помощью IDE:

     - Proof General можно заставить компилировать файл автоматически,
       в момент выполнения команды [Require] внутри PG, присвоив значение
       emacs-переменной [coq-compile-before-require], равное [t].
       Также эту опцию можно включить в меню: "Coq" > "Auto Compilation" >
       "Compile Before Require".

     - В CoqIDE: Открываем [Basics.v]; затем, в меню "Compile",
       выбираем "Compile Buffer".

     - Пользователей VSCode приглашаем в терминал, инструкцию см. ниже. (если Вы
       склонировали репозиторий, достаточно вызвать команду `make`.)

    Чтобы скомпилировать [Basics.v] с помощью командной строки, нужно:

     - Сгенерировать [Makefile] с помощью утилиты [rocq makefile],
       устанавливающейся вместе с Rocq. (Если Вы склонировали репозиторий
       целиком, [Makefile] должен быть на месте, и этот шаг можно пропустить.)

         rocq makefile -f _CoqProject *.v -o Makefile

       Вам нужно перезапускать эту команду каждый раз, когда Вы добавляете или,
       наоборот, удаляете файлы Rocq в этой директории.

     - Запустить [make] с соответствующим файлом [.vo] в качестве таргета:

         make Lecture1.vo

       Таргет по умолчанию -- это все файлы в директории:

         make

     - Под капотом, [make] вызывает компилятор Rocq, [rocq compile]. Если есть
       возможность, то используйте [make] вместо явного запуска [rocq] -- кроме
       запуска собственно компилятора, [make] также вычисляет зависимости между
       исходными файлами, чтобы скомпилировать их в правильном порядке.  Но,
       конечно, в крайнем (но не слишком уж ужасном) случае, файлы можно
       компилировать вручную по ходу выполнения заданий. Например, перед началом
       работы над текущим файлом, вам нужно будет запустить следующую команду:

        roqc compile -Q . Lectures Basics.v

       Далее, когда вы закончите работу над заданиями в этой главе:

        rocq compile -Q . Lectures Induction.v

       (Чтобы подготовиться к следующей лекции).  Если по какой-либо причине
       файлы .vo пропадут или устареют, нужно будет вновь запустить обе команды,
       в том же порядке.

    Возможные неисправности:

     - Для большинства вариантов, описанных выше, нужно, чтобы путь к
       исполняемому файлу [rocq] находился в переменной среды [PATH].

     - Если [rocq] Вам сообщает, что не хватает каких-то идентификаторов,
       возможно, функциональность "load path" для Rocq была установлена
       неправильно.  Команда [Print LoadPath.] может оказаться полезной,
       чтобы разобраться с проблемой.

     - При компиляции следующих глав, если Вы видите сообщение навроде

        Compiled library Induction makes inconsistent assumptions over
        library Basics

       скорее всего, дело в том, что библиотека [Basics] была изменена и
       перекомпилирована, a [Induction], которая от неё зависит -- нет.
       Просто перекомпилируйте [Induction]; либо всё вместе, если слишком много
       библиотек столкнулось с той же проблемой. Повторюсь, для этого достаточно
       запустить [make]; если даже это не поможет, попробуйте [make clean; make].

     - Если и это не помогло, возможно, на Вашем компьютере установлено сразу
       несколько несовместимых версий Rocq.  Возможно, команды, которые Вы
       выполняете в терминале (вроде [rocq compile]) запускаются не с той
       версией Rocq, с которой взаимодействуют Proof General или CoqIDE.
       В CoqIDE для обхода этой проблемы можно компилировать только средствами
       CoqIDE (т.е. вызывать "make" из меню), избегая прямого использования
       [rocq]. *)

(* ################################################################# *)
(** * Доказательство по индукции *)

(** Мы можем доказать, что [0] является нейтральным элементом для [+] _слева_,
    используя только [рефлексивность].  Но доказательство того, что это также
    нейтральный элемент _справа_ ... *)

Theorem add_0_r_firsttry : forall n:nat,
  n + 0 = n.

(** ... невозможно сделать таким же простым способом.  Простое применение
    [рефлексивности] не работает, поскольку [n] в [n + 0] является произвольным
    неизвестным числом, поэтому [match] в определении [+] не может быть упрощён.
*)

Proof.
  intros n.
  simpl. (* Ничего не делает! *)
Abort.

(** Разбор случаев с помощью [destruct n] тоже не позволяет особо продвинуться:
    тот случай, где мы предполагаем, что [n = 0], проходит нормально, но в
    случае, когда [n = S n'] для некоторого [n'], мы точно так же застреваем. *)

Theorem add_0_r_secondtry : forall n:nat,
  n + 0 = n.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    reflexivity. (* пока хорошо... *)
  - (* n = S n' *)
    simpl.       (* ...а тут мы опять застряли *)
Abort.

(** Мы могли бы использовать [destruct n'], чтобы продвинуться еще на один
    шаг, но, поскольку [n] может быть сколь угодно большим, мы никогда
    не получим то, что нам нужно, если будем продолжать в том же духе. *)

(** Чтобы доказывать интересные факты о числах, списках и других
    индуктивно определяемых множествах, нам часто требуется более мощный принцип
    рассуждений: _по индукции_.

    Вспомним (вероятно, из курса дискретной математики) _принцип математической
    индукции_: если [P(n)] -- некоторое утверждение о натуральном числе [n], и
    мы хотим показать, что [P] выполнено для всех чисел [n], мы можем рассуждать
    следующим образом:
         - показать, что [P(O)] выполнено;
         - показать, что для любого [n'], если выполняется [P(n')], то
           выполняется и [P(S n')];
         - заключить, что [P(n)] выполняется для всех [n].

    В Rocq шаги те же: мы начинаем с цели доказать [P(n)] для всех [n] и
    разбиваем эту задачу (с помощью тактики [induction]) на две отдельные
    подцели: в одной мы должны показать [P(O)], а в другой --
    [P(n') -> P(S n')].  Вот как это работает для нашей теоремы: *)

Theorem add_0_r : forall n:nat, n + 0 = n.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite -> IHn'. reflexivity.  Qed.

(** Как и [destruct], тактика [induction] получает клозу [as...],
    в которой указываются имена переменных, которые будут введены в подцелях.
    Поскольку подцелей две, клоза [as...] состоит из двух частей, разделенных
    вертикальной чертой, [|].  (Строго говоря, мы можем опустить предложение
    [as...] и Rocq выберет имена за нас.  На практике это плохая идея, так как
    автоматический выбор Rocq, как правило, приводит к путанице.)

    В первой подцели [n] заменяется на [0].  Новые переменные не вводятся
    (поэтому первая часть [as...] пуста), и цель становится [0 = 0 + 0],
    что легко доказать по упрощению.

    Во второй подцели [n] заменяется на [S n'], а предположение [n' + 0 = n']
    добавляется в контекст с именем [IHn'] (т.е. гипотеза индукции для [n']).
    Эти два имени указаны во второй части предложения [as...].  Целью в этом
    случае становится [S n' = (S n') + 0], что упрощается
    до [S n' = S (n' + 0)], что, в свою очередь, следует из [IHn']. *)

Theorem minus_n_n : forall n,
  minus n n = 0.
Proof.
  (* РАЗБИРАЕМ НА ЛЕКЦИИ *)
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** (Использование тактики [intros] в этих доказательствах на самом деле
    излишне.  При применении к цели, содержащей переменные под квантором
    всеобщности, тактика [induction] автоматически перенесет их в контекст по
    мере необходимости.) *)

(** **** Упражнение: 2 звезды, стандартное, очень полезное (basic_induction)

    Докажите с помощью индукции. Возможно, вам понадобятся ранее полученные
    результаты. *)

Theorem mul_0_r : forall n:nat,
  n * 0 = 0.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_n_Sm : forall n m : nat,
  S (n + m) = n + (S m).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem add_comm : forall n m : nat,
  n + m = m + n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem add_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (double_plus)

    Рассмотрим следующую функцию, которая удваивает свой аргумент: *)

Fixpoint double (n:nat) :=
  match n with
  | O => O
  | S n' => S (S (double n'))
  end.

(** Используйте индукцию, чтобы доказать следующий простой факт о [double]: *)

Lemma double_plus : forall n, double n = n + n .
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (eqb_refl)

    Следующая теорема связывает вычислительное равенство [=?] в
    [nat] с равенством по определению [=] в [bool]. *)

Theorem eqb_refl : forall n : nat,
  (n =? n) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, по желанию (even_S)

    Одним из неудобных аспектов нашего определения [even n] является
    рекурсивный вызов [n - 2]. Это затрудняет доказательство свойств [even]
    при выполнении индукции по [n], поскольку нам может понадобиться
    индукционная гипотеза о [n - 2]. Следующая лемма дает альтернативную
    формулировку [even (S n)], которая лучше работает с индукцией: *)

Theorem even_S : forall n : nat,
  even (S n) = negb (even n).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Доказательства внутри доказательств *)

(** В Rocq, как и в неформальной математике, большие доказательства часто
    разбивают на последовательность теорем, причем более поздние доказательства
    ссылаются на более ранние теоремы.  Но иногда доказательство будет включать
    в себя некоторые другие факты, которые слишком тривиальны и не представляют
    интереса, чтобы утруждать себя присвоением ему собственного имени на верхнем
    уровне.  В таких случаях удобно иметь возможность просто сформулировать и
    доказать необходимую "под-теорему" прямо в том месте, где она используется.
    Тактика [replace] позволяет нам это делать. *)

Theorem mult_0_plus' : forall n m : nat,
  (n + 0 + 0) * m = n * m.
Proof.
  intros n m.
  replace (n + 0 + 0) with n.
  - reflexivity.
  - rewrite add_comm. simpl. rewrite add_comm. reflexivity.
Qed.

(** Тактика [replace e1 with e2] вводит две подцели.

    Первая подцель совпадает с целью до вызова [replace] с заменой [e1] на [e2].
    Вторая подцель -- само равенство [e1 = e2]. *)

(** В качестве другого примера предположим, что мы хотим доказать,
    что [(n + m) + (p + q) = (m + n) + (p + q)]. Единственное различие
    между двумя сторонами [=] заключается в том, что аргументы [m] и [n]
    для первого внутреннего [+] меняются местами, поэтому, похоже, у нас должно
    получиться использовать коммутативность сложения ([add_comm]), чтобы
    переписать одно в другое. Однако тактика [rewrite] не слишком умна
    в отношении того, _где_ она применяет переписывание.  Здесь есть три
    варианта использования [+], и оказывается, что [rewrite -> add_comm]
    повлияет только на _внешний_ плюс... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* Нам просто нужно заменить (n + m) на (m + n)... выглядит так, как будто
     add_comm должен помочь! *)
  rewrite add_comm.
  (* Не работает... Rocq переписывает не тот плюс! :-( *)
Abort.

(** Чтобы использовать [add_comm] там, где нам это нужно, мы можем заменить
    [n + m] на [m + n] с помощью [replace], а затем доказать [n + m = m + n],
    используя [add_comm]. *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  replace (n + m) with (m + n).
  - reflexivity.
  - rewrite add_comm. reflexivity.
Qed.

(* ################################################################# *)
(** * Формальные и неформальные доказательства *)

(** "Неформальные доказательства -- это алгоритмы;
    формальные доказательства -- это код." *)

(** Что представляет собой успешное доказательство математического утверждения?
    Этот вопрос волновал философов на протяжении тысячелетий, но приблизительное
    определение может быть таким: Доказательство математического утверждения [P]
    -- это письменный (или устный) текст, который вселяет в читателя или
    слушателя уверенность в том, что [P] истинно -- неопровержимый аргумент в
    пользу истинности [P].  То есть, доказательство -- это акт коммуникации.

    В актах коммуникации могут участвовать разные типы читателей.  С одной
    стороны, "читателем" может быть программа, подобная Rocq, и в этом случае
    "вера" заключается в том, что [P] может быть механически выведено
    из определенного набора формальных логических правил, а доказательство --
    это рецепт, которым руководствуется программа при проверке этого факта.
    Такие _рецепты_ -- это формальные доказательства.

    В более привычном случае, читателем может быть человек, и тогда
    доказательство будет написано на русском или каком-либо другом естественном
    языке и, следовательно, обязательно будет _неформальным_.  Здесь критерии
    успеха указаны менее четко.  "Достоверное" доказательство -- это такое,
    которое заставляет читателя поверить в [P].  Но одно и то же доказательство
    может быть прочитано множеством разных читателей, некоторых из которых может
    убедить определенный способ формулировки аргументов, в то время как другие
    могут и не поверить. Некоторые читатели могут быть особенно педантичными,
    неопытными или просто толстокожими; единственный способ убедить их -- это
    привести аргументацию в мельчайших деталях.  Но другие читатели, более
    знакомые с областью, могут счесть все эти подробности настолько чрезмерными,
    что они потеряют нить повествования; все, чего они хотят, -- это чтобы им
    рассказали основные идеи, поскольку им легче самим разобраться в деталях,
    чем продираться через их изложение их в письменном виде. В конечном
    счете, универсального стандарта не существует, потому что не существует
    единого способа написания неформального доказательства, которое
    гарантированно убедило бы каждого мыслимого читателя.

    Однако на практике математики разработали богатый набор условных обозначений
    и идиом для написания статей о сложных математических объектах, которые --
    по крайней мере, в рамках определенного сообщества -- делают коммуникацию
    довольно надежной.  Условности этой стилизованной формы общения задают
    достаточно четкий стандарт для рассуждений о качестве доказательств.

    Поскольку в этом курсе мы используем Rocq, мы будем работать в значительной
    степени с формальными доказательствами.  Но это не значит, что мы можем
    полностью забыть о неформальных доказательствах!  Формальные доказательства
    полезны во многих отношениях, но это _не очень_ эффективный способ передачи
    идей между людьми. *)

(** Например, вот доказательство ассоциативности сложения: *)

Theorem add_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  simpl. rewrite IHn'. reflexivity.  Qed.

(** Rocq такое доказательство вполне устраивает.  Однако человеку в этом сложно
    разобраться.  Мы можем использовать комментарии и маркеры, чтобы показать
    структуру более четко... *)

Theorem add_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite IHn'. reflexivity.   Qed.

(** ... и, если Вы освоились с Rocq, то, возможно, сможете прокрутить в уме одну
    тактику за другой и представить состояние контекста и стека целей в каждой
    точке, но если бы доказательство было хотя бы немного сложнее, это было бы
    практически невозможно.

    (Педантичный) математик написал бы доказательство как-то так: *)

(** - _Теорема_: Для любых [n], [m] и [p],

      n + (m + p) = (n + m) + p.

    _Доказательство_: Индукцией по [n].

    - База индукции: [n = 0].  Мы должны показать, что

        0 + (m + p) = (0 + m) + p.

      Это напрямую следует из определения [+].

    - Переход: пусть [n = S n']. По предположению индукции

        n' + (m + p) = (n' + m) + p.

      Нам нужно показать, что

        (S n') + (m + p) = ((S n') + m) + p.

      По определению [+], это следует из

        S (n' + (m + p)) = S ((n' + m) + p),

      что непосредственно следует из индукционной гипотезы.  _ЧТД_. *)

(** Общая форма доказательства в основном схожа, и, конечно, это не случайно:
    Rocq был разработан таким образом, что тактика [induction] генерирует те же
    подцели, в том же порядке, что и основные пункты, которые написал бы
    математик.  Но существуют существенные различия в деталях: формальное
    доказательство в некоторых отношениях более детально (например,
    при использовании [рефлексивности]), но гораздо менее явно в других
    (в частности, "состояние доказательства" в любой заданной точке
    доказательства Rocq полностью неявно, в то время как неформальное
    доказательство несколько раз напоминает читателю, как обстоят дела). *)

(** **** Упражнение: 2 звезды, сложное, по желанию (add_comm_informal)

    Переведите Ваше решение [add_comm] в неформальное доказательство:

    Теорема: Сложение коммутативно.

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_add_comm_informal : option (nat*string) := None.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, по желанию (eqb_refl_informal)

    Напишите неформальное доказательство следующей теоремы, используя
    неформальное доказательство [add_assoc] в качестве примера.  Просто
    перефразировать тактики Rocq на русский недостаточно!

    Теорема: [(n =? n) = true] для любого [n].

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_eqb_refl_informal : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * Больше упражнений *)

(** **** Упражнение: 3 звезды, стандартное, очень полезное (mul_comm)

    Используя [replace], докажите [add_shuffle3].  Индукция здесь не нужна. *)

Theorem add_shuffle3 : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь докажите коммутативность умножения.  Возможно, Вам потребуются
    вспомогательные теоремы (которые также нужно сформулировать и доказать).
    Подсказка: чему равно [n * (1 + k)]? *)

Theorem mul_comm : forall m n : nat,
  m * n = n * m.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное, по желанию (more_exercises)

    Возьмите чистый лист бумаги.  Для каждой из следующих теорем, сперва
    обдумайте, (а) можно ли доказать её только упрощениями и переписываниями,
    (б) также нужен разбор случаев ([destruct]) или (c) также требуется индукция.
    Выпишите Ваши предсказания.  Затем заполните доказательства.  (Сдавать
    листочек не нужно; это лишь предложение порефлексировать перед хакингом!) *)

Theorem leb_refl : forall n:nat,
  (n <=? n) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem zero_neqb_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem S_neqb_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem all3_spec : forall b c : bool,
  orb
    (andb b c)
    (orb (negb b)
         (negb c))
  = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Из Nat в Bin и обратно *)

(** Напомним определение типа [bin] из [Basics]: *)

Inductive bin : Type :=
  | Z
  | B0 (n : bin)
  | B1 (n : bin)
.
(** Перед началом работы с упражнениями, замените определения-заглушки [incr] и
    [bin_to_nat] Вашими решениями из [Basics].  Тогда мы сможем проставить
    оценку за Вашу работу над этой главой отдельно от предыдущей. *)

Fixpoint incr (m:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Fixpoint bin_to_nat (m:bin) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** В главе [Basics] мы сделали несколько "юнит-тестов" [bin_to_nat], но мы
    не доказали её корректность. Теперь мы это сделаем. *)

(** **** Упражнение: 3 звезды, стандартное, очень полезное (binary_commute)

    Докажите, что следующая диаграмма коммутирует:

                            incr
              bin ----------------------> bin
               |                           |
    bin_to_nat |                           |  bin_to_nat
               |                           |
               v                           v
              nat ----------------------> nat
                             S

    Т.е., докажите, что инкрементировать двоичную запись числа и затем
    перевести её в унарную запись -- то же самое, что сначала
    перевести в унарную запись, а затем инкрементировать её.

    Если для упрощения доказательства Вам нужно изменить определения [incr] либо
    [bin_to_nat], прошу, не стесняйтесь! *)

Theorem bin_to_nat_pres_incr : forall b : bin,
  bin_to_nat (incr b) = 1 + bin_to_nat b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды, стандартное (nat_bin_nat) *)

(** Выпишите функцию для преобразования унарной записи в бинарную. *)

Fixpoint nat_to_bin (n:nat) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Докажите, что если начать с произвольного [nat], перевести его в [bin],
    а затем обратно, получится тот же самый [nat], с которого мы и начали.

    Подсказка: это доказательство должно пройти легко, если использовать
    предыдущее упражнение об [incr] в качестве леммы. Если это не так, вернитесь
    к Вашим определениям используемых функций: возможно, они сложнее, чем нужно.
    Так происходит потому, что форма доказательства по индукции повторяет
    рекурсивную структуру верифицируемой программы, так что поддерживайте Ваши
    определения рекурсивных функций настолько простыми, насколько это возможно.
*)

Theorem nat_bin_nat : forall n, bin_to_nat (nat_to_bin n) = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Из Bin в Nat и обратно (Продвинутые упражнения) *)

(** Обратное направление -- начинаем с [bin], переводим в [nat], затем обратно
    в [bin] -- оказывается не без подводных камней. Например, следующая теорема
    неверна. *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** Давайте разберёмся, почему это свойство не выполняется, и как
    сформулировать и доказать правильную версию. Начнём с некоторых,
    казалось бы, не относящихся к делу лемм: *)

(** **** Упражнение: 2 звезды, сложное (double_bin) *)

(** Докажите следующую лемму о введённой ранее функции [double]. *)

Lemma double_incr : forall n : nat, double (S n) = S (S (double n)).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь определите аналогичную функцию удвоения для [bin]. *)

Definition double_bin (b:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Убедитесь, что Ваша функция правильно удваивает ноль. *)

Example double_bin_zero : double_bin Z = Z.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Докажите следующую лемму, соответствующую лемме [double_incr]. *)

Lemma double_incr_bin : forall b,
    double_bin (incr b) = incr (incr (double_bin b)).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Вернёмся к нашей желанной теореме: *)

Theorem bin_nat_bin_fails : forall b, nat_to_bin (bin_to_nat b) = b.
Abort.

(** Теорема не выполняется, потому что существуют некоторые [bin] такие, что мы
    не обязательно вернемся к исходному [bin], но вместо этого к
    "эквивалентному" [bin].  (Мы намеренно оставляем это понятие неопределенным,
    чтобы вы могли подумать.)

    Объясните в комментарии ниже, почему возникает этот сбой. Ваше объяснение не
    будет оцениваться, но важно, чтобы Вы уяснили его для себя, прежде чем
    переходить к следующей части. Если Вы застряли здесь, подумайте об
    альтернативных реализациях [double_bin], которые, возможно, не удовлетворяют
    [double_bin_zero], но в остальном похожи на правильную. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(** Чтобы решить эту проблему, мы можем ввести функцию _нормализации_, которая
    выбирает простейший [bin] из всех эквивалентных [bin]. Тогда мы сможем
    доказать, что преобразование из [bin] в [nat] и обратно приводит к
    нормализованным, простейшим [bin]-ам. *)

(** **** Упражнение: 4 звезды, сложное (bin_nat_bin) *)

(** Определите [normalize]. Вам нужно будет сделать его как можно более простым,
    насколько это возможно, для того, чтобы последующие проверки прошли гладко.
    Не используйте [bin_to_nat] или [nat_to_bin], но используйте [double_bin].

    Подсказка: Структурируйте рекурсию таким образом, чтобы она _всегда_
    доходила до конца [bin]-а и обрабатывала каждый бит только один раз. Не
    пытайтесь "заглядывать вперед" в будущие биты. *)

Fixpoint normalize (b:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Будет разумным сперва привести несколько [Примеров], чтобы убедиться,
    что ваше определение [normalize] работает так, как вы предполагаете, прежде
    чем продолжить. Они не будут оцениваться, но всё же введите их ниже. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(** Наконец, докажите основную теорему. Шаг индукции может быть с подвохом.

    Подсказка: Начните с попытки доказать основное утверждение, посмотрите, где
    вы застряли, и посмотрите, сможете ли вы придумать лемму -- возможно,
    требующую своё собственное индуктивное доказательство -- которая позволит
    продвинуться в основном доказательстве. Мы использовали одну лемму для
    случая [B0] (в которой также используется [double_incr_bin]) и другую для
    случая [B1]. *)

Theorem bin_nat_bin : forall b, nat_to_bin (bin_to_nat b) = normalize b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* 2026-02-12 15:23 *)
