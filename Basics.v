(** * Основы: Функциональное программирование на Rocq *)

(*
          #####################################################
          ###  ПОЖАЛУЙСТА, НЕ РАСПРОСТРАНЯЙТЕ ВАШИ РЕШЕНИЯ  ###
          #####################################################
*)

(* ################################################################# *)
(** * Введение *)

(** Функциональный стиль программирования основан на простой, повседневной
    математической интуиции: если процедура или метод не имеют побочных
    эффектов, то (игнорируя эффективность) все, что нам нужно знать для работы
    с ним -- это то, как он сопоставляет входные данные с выходными, то есть
    мы можем думать о нём просто как о конкретном методе вычисления
    математической функции.  Это одно из значений слова "функциональный" в
    словосочетании "функциональное программирование".  Прямая связь между
    программами и простыми математическими объектами поддерживает как
    формальную корректность доказательств, так и обоснованные неформальные
    рассуждения о поведении программы.

    Другой смысл, в котором функциональное программирование является
    "функциональным", заключается в том, что оно подчеркивает использование
    функций в качестве значений _первого класса_ -- т.е. значений, которые
    могут передаваться в качестве аргументов другим функциям, возвращаться в
    качестве результатов, включаться в структуры данных и т.д.  Понимание
    того, что функции можно рассматривать как данные, порождает множество
    полезных и мощных идиом программирования.

    Другие общие черты функциональных языков включают в себя _алгебраические
    типы данных_ и _сопоставление c образцом_, которые упрощают создание
    сложных структур данных и манипулирование ими, а также _полиморфные
    системы типов_, поддерживающие абстракцию и повторное использование кода.
    В Rocq доступны все эти функции.

    В первой половине этого занятия представлены наиболее важные элементы
    собственного функционального языка программирования Rocq, _Gallina_.
    Во второй части представлены некоторые базовые _тактики_, которые можно
    использовать для доказательства свойств программ, написанных на Gallina.
*)

(* ################################################################# *)
(** * Сдача домашних заданий *)

(** Мы используем скрипты на Rocq для автопроверки Ваших домашних заданий.
    Чтобы эти скрипты работали корректно (и чтобы вы получили полную оценку за
    свою работу!), пожалуйста, внимательно следуйте этим правилам:

      - Не меняйте названия упражнений. В противном случае скрипты для
        выставления оценок не смогут найти Ваше решение.
      - Не удаляйте упражнения.  Если вы пропустите какое-либо упражнение
        (например, поскольку оно помечено как "необязательное" или потому что вы
        не можете его решить), можно оставить частичное доказательство в вашем
        файле [.v]; в этом случае, пожалуйста, убедитесь, что оно заканчивается
        ключевым словом [Admitted] (а не, например, [Abort]).
      - В своих решениях можно использовать дополнительные определения
        (вспомогательных функций, полезных лемм и т.д.).  Вы можете поместить их
        перед теоремой, которую вас просят доказать.
      - Если вы вводите вспомогательную лемму, которую вы в конечном итоге не
        можете доказать, заканчивайте её словом [Admitted], затем не забудьте
        также закончить основную теорему, в которой вы ее используете, словом
        [Admitted], а не [Qed].  Это поможет вам получить частичный балл в том
        случае, если вы используете эту основную теорему для решения
        последующего упражнения.

    Вы также заметите, что каждый файл (например, этот, [Basics.v])
    сопровождается _тестирующим скриптом_ ([BasicsTest.v]), который
    автоматически подсчитывает баллы за готовые домашние задания в этой главе.
    Эти скрипты в основном предназначены для автопроверки, но вы также можете
    воспользоваться ими, чтобы еще раз проверить, правильно ли отформатирован
    ваш файл, прежде чем сдать его.  Ввполните в терминале команду
    "[make BasicsTest.vo]" или проделайте следующие действия:

       coqc -Q . Lectures Basics.v
       coqc -Q . Lectures BasicsTest.v

    Более подробную информацию о том, как интерпретировать выходные данные
    тестирующих скриптов, смотрите далее.

    Сам тестирующий скрипт ([BasicsTest.v]) сдавать не нужно!

    Для сдачи домашних заданий сделайте следующее:

      - Создайте приватную копию репозитория курса.
      - Выдайте лектору и ассистенту доступ к Вашей приватной копии.
      - Решайте домашнее задание прямо в файлах [Basics.v], [Induction.v],...
      - Для сдачи домашнего задания на проверку создавайте коммиты с Вашими
        изменениями и отправляйте их в Вашу приватную копию.
      - В репозитории настроен GitHub Workflow, запускающий автопроверку при
        каждом коммите в основную ветку. Это поможет и Вам, и проверяющему сразу
        увидеть результаты проверки. *)

(* ################################################################# *)
(** * Типы данных и функции *)

(* ================================================================= *)
(** ** Типы-перечисления *)

(** Одной из примечательных особенностей Rocq является то, что встроенная
    в него функциональность _чрезвычайно_ ограничена.  Например, вместо
    предоставления обычного набора атомарных типов данных (логические значения,
    целые числа, строки и т.д.), Rocq предлагает мощный механизм для определения
    новых типов данных с нуля, предоставляя возможность задать все эти знакомые
    типы на уровне библиотек.

    Естественно, дистрибутив Rocq поставляется с обширной стандартной
    библиотекой, предоставляющей определения логических значений, чисел и многих
    распространенных структур данных, таких как списки и хэш-таблицы.  Но в этих
    библиотечных определениях нет ничего волшебного или примитивного.  Чтобы
    проиллюстрировать это, в этом курсе мы самостоятельно восстановим (почти)
    все определения, которые нам нужны, вместо того чтобы брать их из
    стандартной библиотеки. *)

(* ================================================================= *)
(** ** Дни недели *)

(** Чтобы увидеть, как работает этот механизм определений, давайте начнем
    с очень простого примера.  Следующее объявление сообщает Rocq, что мы
    определяем набор значений данных -- _тип_. *)

Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

(** Новый тип называется [day], а его членами являются [monday], [tuesday]
    и т.д.

    Определив [day], мы можем написать функции, которые работают с днями недели.
*)

Definition next_working_day (d:day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

(** Обратите внимание, что типы аргументов и возвращаемых значений этой
    функции объявлены здесь явно.  Как и в большинстве функциональных языков
    программирования, Rocq часто может сам определять эти типы, если они не
    заданы явно -- т.е. он может выполнять _вывод типов_ -- но, как правило, мы
    выписываем их явно, чтобы облегчить чтение. *)

(** Определив функцию, мы можем проверить, работает ли она на некоторых
    примерах.  На самом деле в Rocq есть три разных способа выполнения примеров.
    Во-первых, мы можем использовать команду [Compute] для вычисления составного
    выражения, включающего [next_working_day]. *)

Compute (next_working_day friday).
(* ==> monday : day *)

Compute (next_working_day (next_working_day saturday)).
(* ==> tuesday : day *)

(** (Мы показываем ответы Rocq в комментариях; если у вас под рукой есть
    компьютер, это отличный момент, чтобы запустить интерпретатор Rocq в вашей
    любимой среде разработки (инструкции по установке смотрите в README) и
    попробовать его самостоятельно.  Загрузите этот файл, [Basics.v], из
    репозитория, найдите приведенный выше пример, загрузите его в Rocq и
    понаблюдайте за результатом. *)

(** Также мы можем записать, какой результат мы ожидаем получить
    в виде т.н. [Примеров]: *)

Example test_next_working_day:
  (next_working_day (next_working_day saturday)) = tuesday.

(** Это объявление делает две вещи: оно создает утверждение (что вторым
    рабочим днем после [субботы] является [вторник]) и присваивает утверждению
    имя, которое можно использовать для ссылки на него позже. Создав
    утверждение, мы также можем попросить Rocq проверить его следующим образом:
*)

Proof. simpl. reflexivity.  Qed.

(** Детали сейчас не важны, но, по сути, этот небольшой скрипт можно
    прочитать как "То, что мы утверждаем, можно доказать, заметив, что обе
    стороны равенства вычисляются в одно и то же значение". *)

(** А ещё мы можем попросить у Rocq _извлечь_ из нашего [Определения]
    программу, написанную в языке с более производительным компилятором.
    Обычно для этих целей выбирают OCaml, Scheme или Haskell.  Таким образом,
    мы можем получать крайне эффективный машинный код, про который была
    доказана корректность его работы.

    (Конечно, здесь мы принимаем на веру корректность работы компилятора
    OCaml/Haskell/Scheme, а также корректность самого механизма извлечения
    кода, но это уже большой шаг вперёд по сравнению с тем, как разрабатывают
    абсолютное большинство софта!) *)

(** Инструкция [Require Export] в следующей строке указывает Rocq использовать
    модуль [String] из стандартной библиотеки.  Мы будем использовать строки
    для различных целей в последующих занятиях, но нам нужно [Потребовать] это
    здесь, чтобы скрипты автопроверки могли использовать строки для своих целей.
*)
From Stdlib Require Export String.

(* ================================================================= *)
(** ** Логические значения *)

(** Аналогично дням недели, определённым выше, мы можем определить
    стандартный тип логических значений [bool] с элементами [true] и [false]. *)

Inductive bool : Type :=
  | true
  | false.

(** Функции над логическими значениями могут быть определены таким же
    образом, как выше: *)

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** (Хотя здесь мы используем наши собственные логические значения ради
    создания всего с нуля, Rocq, конечно же, по умолчанию предоставляет
    реализацию логических значений, а также множество полезных функций и лемм.
    Везде, где это было возможно, мы давали нашим собственным определениям и
    теоремам названия, соответствующие тем, что есть в стандартной библиотеке.)
*)

(** Последние два из них иллюстрируют синтаксис Rocq для определения
    функций с несколькими аргументами.  Соответствующий синтаксис _применения_
    функций с несколькими аргументами проиллюстрирован следующими
    "юнит-тестами", которые представляют собой полную спецификацию -- таблицу
    истинности -- для функции [orb].: *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.

(** Мы также можем ввести немного знакомого инфиксного синтаксиса для
    логических операций, которые мы только что определили. Команда [Notation]
    определяет новую символьную запись для существующих определений. *)

Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).

Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.

(** _Примечание о нотации_: В файлах [.v] мы используем квадратные скобки
    для выделения фрагментов кода Rocq в комментариях; это соглашение, также
    используемое инструментом документации [coqdoc], визуально отделяет их от
    окружающего текста.  В HTML-версии файлов эти фрагменты текста выделены
    другим шрифтом. *)

(** Эти примеры также дают повод показать еще одну маленькую особенность
    Gallina: условные выражения... *)

Definition negb' (b:bool) : bool :=
  if b then false
  else true.

Definition andb' (b1:bool) (b2:bool) : bool :=
  if b1 then b2
  else false.

Definition orb' (b1:bool) (b2:bool) : bool :=
  if b1 then true
  else b2.

(** Условные выражения в Rocq точно такие же, как и в любом другом языке,
    с одним небольшим обобщением:

    Поскольку тип [bool] не встроен, Rocq фактически поддерживает условные
    выражения для _любого_ индуктивно определенного типа с ровно двумя
    конструкторами в его определении.  Условие считается истинным, если оно
    вычисляется как первый конструктор [Индуктивного] определения (которое,
    просто потому что мы так выбрали, в данном случае называется [true]), и
    ложной, если она вычисляется как второй. *)

(** Например, мы можем определить следующий тип данных [bw] с помощью двух
    конструкторов, представляющих черный ([b]) и белый ([w]) цвета, и определить
    функцию [invert], которая инвертирует значения этого типа с помощью
    условного выражения. *)

Inductive bw : Type :=
  | bw_black
  | bw_white.

Definition invert (x: bw) : bw :=
  if x then bw_white
  else bw_black.

Compute (invert bw_black).
(* ==> bw_white : bw *)

Compute (invert bw_white).
(* ==> bw_black : bw *)

(** **** Упражнение: 1 звезда, стандартное (nandb)

    Команда [Admitted] может использоваться как заглушка для неполного
    доказательства.  Мы используем ее в упражнениях, чтобы указать части,
    которые мы оставляем для Вас, т.е. ваша задача -- заменить [Допущенные]
    части настоящими доказательствами.

    Удалите "[Admitted.]" и завершите определение следующей функции; затем
    убедитесь, что Rocq справляется с проверкой каждого из приведенных ниже
    [Примеров].  (Т.е. заполните каждое доказательство, следуя приведенной выше
    модели тестов [orb], и убедитесь, что Rocq их принимает.) Функция должна
    возвращать [true], если один или оба ее входа равны [false].

    Подсказка: если [simpl] не упростит цель вашего доказательства, вероятно,
    это потому, что вы определили [nandb] без использования выражения [match].
    Попробуйте другое определение [nandb] или просто пропустите [simpl] и
    перейдите непосредственно к [reflexivity]. Мы объясним этот феномен позднее
    в рамках этого занятия. *)

Definition nandb (b1:bool) (b2:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_nandb1:               (nandb true false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное (andb3)

    Сделайте то же самое для функции [andb3] ниже. Эта функция должна возвращать
    [true] когда все её входы [true], и [false] в противном случае. *)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_andb31:                 (andb3 true true true) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Типы *)

(** Каждое выражение в Rocq имеет тип, описывающий, какого сорта значение оно
    вычисляет. Команда [Check] просит у Rocq распечатать тип выражения. *)

Check true.
(* ===> true : bool *)

(** Если аргумент [Check] проаннотирован типом, Rocq заодно проверит, что тип
    выражения сходится с указанным, и сообщит об ошибке, если это не так. *)

Check true
  : bool.
Check (negb true)
  : bool.

(** Функции вроде [negb] -- тоже значения, точно такие же, как [true] и
    [false].  Типы функций пишутся с помощью стрелок. *)

Check negb
  : bool -> bool.

(** Тип [negb], записываемый как [bool -> bool] и произносимый как "[bool]
    стрелка [bool]", можно прочитать как "Получив на вход данные типа [bool],
    эта функция возвращает данные типа [bool]". Аналогично, тип [and],
    записанный как [bool -> bool -> bool], может быть прочитан следующим
    образом: "Получив на вход два значения, каждое из которых имеет тип [bool],
    эта функция возвращает значение типа [bool]". *)

(* ================================================================= *)
(** ** Новые типы на основе старых *)

(** Типы, которые мы определили до сих пор, являются примерами
    "типов-перечислений": их определения явно перечисляют конечный набор
    элементов, называемых _конструкторами_.  Вот более интересное определение
    типа, где один из конструкторов принимает аргумент: *)

Inductive rgb : Type :=
  | red
  | green
  | blue.

Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).

(** Давайте посмотрим чуть внимательнее.

    [Индуктивное] определение делает две вещи:

    - Вводит несколько новых _конструкторов_. Так, [red], [primary], [true],
      [false], [monday] являются конструкторами.

    - Группирует конструкторы в новый именованный тип, вроде
      [bool], [rgb] и [color].

    _Конструкторные выражения_ получаются применением конструктора к
    некоторому числу других конструкторных выражений, в соответствии с типами
    конструктора и его аргументов.
    Примеры правильных конструкторных выражений:
        - [red]
        - [true]
        - [primary red]
    Примеры НЕправильных конструкторных выражений:
        - [red primary]
        - [true red]
        - [primary (primary red)]
*)

(** В частности, определения [rgb] и [color] указывают, какие
    конструкторные выражения принадлежат множествам [rgb] и [color]:

    - [red], [green] и [blue] принадлежат множеству [rgb];
    - [black] и [white] относятся к множеству [color];
    - если [p] является конструкторным выражением, принадлежащим множеству
      [rgb], то [primary p] ("конструктор [primary], примененный к аргументу
      [p]") является конструкторным выражением, принадлежащим множеству
      [color]; и
    - конструкторные выражения, принадлежащие множествам [rgb] и [color], могли
      быть сформированы только одним из способов выше. *)

(** Определим функции, действующие на цветах, с помощью сопоставления с
    образцом -- в точности так же, как мы это делали для дней недели и
    логических значений. *)

Definition monochrome (c : color) : bool :=
  match c with
  | black => true
  | white => true
  | primary x => false
  end.

(** Раз конструктор [primary] принимает аргумент, образец, сопоставляемый
    [primary], должен включать либо переменную, как мы сделали выше (обратите
    внимание, что имя [x] выбрано произвольно), либо другой паттерн
    подходящего типа (как ниже). *)

Definition isred (c : color) : bool :=
  match c with
  | black => false
  | white => false
  | primary red => true
  | primary _ => false
  end.

(** Паттерн "[primary _]" здесь значит "конструктор [primary], применённый к
    любому конструктору типа [rgb], кроме [red]." *)

(** (Образец-джокер [_] имеет тот же эффект, что и фиктивная
    переменная-образец [x] в определении [monochrome].) *)

(* ================================================================= *)
(** ** Модули *)

(** Rocq предоставляет _модульную систему_, помогающую в организации
    больших проектов.  Большая часть её функций нам не понадобятся, но одна из
    них здесь будет полезна: если мы поместим набор объявлений между маркерами
    [Module X] и [End X], то в оставшейся части файла после [Конца] модуля на
    эти определения ссылаются как [X.foo] вместо просто [foo].  Мы будем
    использовать этот функционал для ограничения области видимости определений,
    чтобы свободно переиспользовать имена. *)

Module Playground.
  Definition foo : rgb := blue.
End Playground.

Definition foo : bool := true.

Check Playground.foo : rgb.
Check foo : bool.

(* ================================================================= *)
(** ** Кортежи *)

Module TuplePlayground.

(** Для создания типа кортежа можно использовать один конструктор с
    несколькими параметрами. В качестве примера рассмотрим представление четырех
    битов в ниббле (половина байта). Сначала мы определяем тип данных [bit],
    который напоминает [bool] (используя конструкторы [B0] и [B1] для двух
    возможных значений битов) и затем определяем тип данных [nybble], который по
    сути является кортежем из четырех битов. *)

Inductive bit : Type :=
  | B1
  | B0.

Inductive nybble : Type :=
  | bits (b0 b1 b2 b3 : bit).

Check (bits B1 B0 B1 B0)
  : nybble.

(** Конструктор [bits] действует как обёртка для его содержимого.
    Развёртывание может быть выполнено путем сопоставления с образцом, как в
    приведенной ниже функции [all_zero], которая проверяет, все ли биты в ниббле
    равны [B0]. *)

Definition all_zero (nb : nybble) : bool :=
  match nb with
  | (bits B0 B0 B0 B0) => true
  | (bits _ _ _ _) => false
  end.

(** (Нижнее подчёркивание (_) -- _паттерн-джокер_, с помощью которого не нужно
    выдумывать имена переменных, которые потом всё равно не будут
    использоваться.) *)

Compute (all_zero (bits B1 B0 B1 B0)).
(* ===> false : bool *)
Compute (all_zero (bits B0 B0 B0 B0)).
(* ===> true : bool *)

End TuplePlayground.

(* ================================================================= *)
(** ** Числа *)

(** Мы поместили этот раздел в модуль, чтобы наше собственное определение
    натуральных чисел не мешалось определению из стандартной библиотеки.  В
    оставшейся части занятия мы будем использовать определение из стандартной
    библиотеки. *)

Module NatPlayground.

(** Все типы, которые мы определили до сих пор -- как "перечисляемые",
    такие как [day], [bool] и [bit], так и типы кортежей, такие как [nybble],
    построенные на их основе -- конечны.  Натуральные числа, с другой стороны,
    представляют собой бесконечное множество, поэтому нам нужно будет
    использовать более мощный способ объявления типа для их представления.

    Существует множество вариантов представления чисел. Вы почти наверняка
    знакомы с десятичной системой счисления (основание 10), в которой цифры от 0
    до 9 используются, например, для образования числа 123. Скорее всего, вы
    также сталкивались с шестнадцатеричной системой счисления (основание 16), в
    которой то же самое число представлено как 7B, или восьмеричное (основание
    8), где оно равно 173, или двоичное (основание 2), где оно равно 1111011.
    Используя перечислимый тип для представления цифр, мы могли бы использовать
    любое из них в качестве нашего представления натуральных чисел.
    Действительно, есть обстоятельства, когда каждый из этих вариантов был бы
    полезен.

    Двоичное представление ценно при изготовлении микросхем, потому что цифры
    могут быть представлены только двумя различными уровнями напряжения тока,
    что приводит к упрощению схемы. Аналогично, в данном случае мы хотели бы
    выбрать представление, которое делает _доказательства_ проще.

    На самом деле, существует еще более простое представление чисел, чем в
    двоичной системе, а именно унарный код (основание 1), в котором используется
    только одна цифра (как, возможно, делали наши предки для подсчета дней,
    делая царапины на стенах их пещер). Для представления унарных чисел с
    помощью типа данных Rocq мы используем два конструктора. Конструктор [O]
    (заглавная О) представляет ноль. Конструктор [S], применённый к
    представлению натурального числа n, представляет число n+1, где [S] означает
    "последующий", "successor" (или "царапина", "scratch").  Вот полное
    определение типа данных: *)

Inductive nat : Type :=
  | O
  | S (n : nat).

(** Таким образом, 0 представляется как [O], 1 как [S O], 2 как [S (S O)]
    и т.д.. *)

(** Условно, пункты определения можно прочитать так:
    - [O] -- это натуральное число (помните, что это буква "[O]",
      а не цифра "[0]").
    - [S] можно поставить перед натуральным числом, чтобы получить другое
      натуральное число; то есть, если [n] -- натуральное число, то и [S n]
      тоже. *)

(** Если быть чуть формальнее, то определение [nat] задаёт, как можно
    строить значения типа [nat]:

    - конструкторное выражение [O] принадлежит множеству [nat];
    - если [n] -- конструкторное выражение из множества [nat], то [S n] --
      тоже конструкторное выражение из множества [nat]; и
    - конструкторные выражения, построенные таким способом -- единственные,
      принадлежащие множеству [nat]. *)

(** Наличие этих условий -- та самая мощь [Индуктивных] определений, о
    которой мы говорили ранее.  Из них следует, что множество конструкторных
    выражений [nat] состоит в точности из [O], [SO], [S (S O)], [S (S (S O))] и
    т.д., в то время как [true], [andb true false], [S (S false)] и
    [O (O (O S))] ему не принадлежат.

    Важным моментом здесь является то, что все, что мы делали до сих пор -- это
    просто определение представления чисел: способа их записи. Имена [O] и [S]
    являются произвольными, и на данный момент они не имеют никакого особого
    значения -- это просто два разных знака, которые мы можем использовать для
    записи чисел, вместе с правилом, которое гласит: [nat] будет записан в виде
    некоторой последовательности знаков [S], за которыми следует [O].  Если мы
    захотим, мы можем записать по сути то же самое определение другим образом:
*)

Inductive otherNat : Type :=
  | stop
  | tick (foo : otherNat).

(** А вот _интерпретация_ этих меток возникает тогда, когда мы начинаем
    использовать их для вычислений. *)

(** Мы можем сделать это, написав функции, которые используют
    сопоставление с образцом для натуральных чисел, точно так же, как мы делали
    это выше для логических значений и дней -- например, вот функция,
    вычисляющая число, предшествующее данному: *)

Definition pred (n : nat) : nat :=
  match n with
  | O => O
  | S n' => n'
  end.

(** Вторую ветку можно прочитать так: "если [n] имеет форму [S n']
    для некоторого [n'], то верни это [n']". *)

(** Следующая команда [End] закрывает текущий модуль, поэтому далее
    [nat] будет ссылаться на тип из стандартной библиотеки. *)

End NatPlayground.

(** Поскольку натуральные числа чрезвычайно распространенный тип данных,
    Rocq предоставляет чуть-чуть встроенной магии для их ввода и печати: обычные
    десятичные числа могут использоваться в качестве альтернативы "унарной"
    записи через конструкторы [S] и [O].  Для вывода также используется
    десятичная система счисления: *)

Check (S (S (S (S O)))).
(* ===> 4 : nat *)

Definition minustwo (n : nat) : nat :=
  match n with
  | O => O
  | S O => O
  | S (S n') => n'
  end.

Compute (minustwo 4).
(* ===> 2 : nat *)

(** Конструктор [S] имеет тип [nat -> nat], такой же, как у функций
    [pred] и [minustwo]: *)

Check S        : nat -> nat.
Check pred     : nat -> nat.
Check minustwo : nat -> nat.

(** Все эти функции можно применить к числу, чтобы получить другое число. Однако
    существует фундаментальное различие между [S] и двумя другими функциями:
    такие функции, как [pred] и [minustwo], определяются путем задания _правил
    вычисления_ -- например, определение [pred] говорит, что [pred 2] можно
    упростить до [1], в то время как в определении [S] никакого поведения нет.
    Хотя этот конструктор и _подобен_ функции в том смысле, что он может быть
    применён к аргументу, он _вообще_ ничего не делает!
    Это просто способ записи чисел.

    Посмотрим на самые обыкновенные десятичные числа: число [1] -- это не
    вычисление; это кусок данных.  Когда мы пишем [111] для обозначения числа
    сто одиннадцать, мы используем [1], трижды, чтобы записать конкретное
    представление числа.

    Давайте продолжим и определим еще несколько функций над числами.

    Для наиболее интересных вычислений, связанных с числами, просто
    сопоставления с образцом недостаточно: нам также нужна рекурсия.  Например,
    чтобы проверить, является ли число [n] четным, нам может потребоваться
    рекурсивно проверить, является ли [n-2] четным.  Такие функции вводятся с
    помощью ключевого слова [Fixpoint] вместо [Definition]. *)

Fixpoint even (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => even n'
  end.

(** Мы могли бы определить [odd] похожим объявлением [Fixpoint], но теперь есть
    способ проще: *)

Definition odd (n:nat) : bool :=
  negb (even n).

Example test_odd1:    odd 1 = true.
Proof. simpl. reflexivity.  Qed.
Example test_odd2:    odd 4 = false.
Proof. simpl. reflexivity.  Qed.

(** (Если вы ознакомитесь с этими доказательствами в интерактивном режиме,
    вы можете заметить, что [simpl] на самом деле не влияет на цель -- вся
    работа выполняется с помощью [рефлексивности].  Вскоре мы обсудим, почему.)
*)

Module NatPlayground2.

(** Естественно, рекурсией также можно определить функцию от нескольких
    аргументов. *)

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(** Прибавив три к двум, мы получим пять (ого!): *)

Compute (plus 3 2).
(* ===> 5 : nat *)

(** Упрощения выражения, которые Rocq выполняет в этот момент, можно
    представить следующим образом: *)

(*      [plus 3 2]
   т.е. [plus (S (S (S O))) (S (S O))]
    ==> [S (plus (S (S O)) (S (S O)))]
          по второму случаю в [match]
    ==> [S (S (plus (S O) (S (S O))))]
          по второму случаю в [match]
    ==> [S (S (S (plus O (S (S O)))))]
          по второму случаю в [match]
    ==> [S (S (S (S (S O))))]
          по первому случаю в [match]
   т.е. [5]  *)

(** Для удобства записи, если два или более аргумента имеют одинаковый
    тип, они могут быть записаны вместе.  В определении ниже [(n m : nat)]
    означает то же самое, как если бы мы написали [(n : nat) (m : nat)]. *)

Fixpoint mult (n m : nat) : nat :=
  match n with
  | O => O
  | S n' => plus m (mult n' m)
  end.

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** Мы можем сопоставить с образцом два выражения за раз, поставив запятую
    между ними: *)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

End NatPlayground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
  | O => S O
  | S p => mult base (exp base p)
  end.

(** **** Упражнение: 1 звезда, стандартное (factorial)

    Вспомним стандартное определение факториала:

       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n>0)

    Переведите его на Rocq.

    Убедитесь, что вы поставили [:=] между заголовком, который мы предоставили,
    и Вашим определением.  Если Вы видите ошибку вроде "The reference factorial
    was not found in the current environment", это означает, что Вы забыли
    [:=]. *)

Fixpoint factorial (n:nat) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_factorial1:          (factorial 3) = 6.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** И вновь мы можем сделать числовые выражения более читаемыми с помощью новых
    нотаций для сложения, вычитания и умножения. *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1) : nat.

(** (Аннотации [level], [associativity] и [nat_scope] определяют, как эти
    обозначения обрабатываются синтаксическим анализатором Rocq.  Подробности не
    важны для наших целей, но заинтересованные читатели могут обратиться к
    разделу "Подробнее о нотации" в конце этой главы.)

    Обратите внимание, что эти объявления не меняют определения, которые мы уже
    ввели: это просто инструкции для синтаксического анализатора Rocq читать
    [x + y] как [plus xy] и, наоборот, отображать [plus xy] как [x + y]. *)

(** Когда мы говорим, что в Rocq практически ничего не встроено по умолчанию,
    мы действительно так считаем: даже проверка на равенство определена на
    уровне библиотеки!
    Вот, например, функция [eqb], проверяющая числа на равенство ([eq]) и
    возвращающая логическое значение ([b]) в качестве результата.
    Обратите внимание на вложенные конструкции [match] -- вместо этого мы могли
    бы сопоставлять по образцу оба числа сразу, как в [minus]. *)

Fixpoint eqb (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => eqb n' m'
            end
  end.

(** Аналогично, функция [leb] проверяет, действительно ли первый аргумент не
    больше второго, и возвращает логическое значение. *)

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1:                leb 2 2 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb2:                leb 2 4 = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb3:                leb 4 2 = false.
Proof. simpl. reflexivity.  Qed.

(** Мы будем часто пользоваться этими операциями (особенно [eqb]), так что
    давайте дадим им инфиксные нотации. *)

Notation "x =? y" := (eqb x y) (at level 70) : nat_scope.
Notation "x <=? y" := (leb x y) (at level 70) : nat_scope.

Example test_leb3': (4 <=? 2) = false.
Proof. simpl. reflexivity.  Qed.

(** Теперь у нас есть два символа, которые выглядят как равенство: [=] и
    [=?]. Позже мы расскажем гораздо больше об их различиях и сходствах. А пока
    главное, на что следует обратить внимание, это то, что [x = y] -- это
    логическое _утверждение_, "пропозиция", которую мы можем попытаться
    доказать, в то время как [x =? y] - это логическое _выражение_, значение
    которого (либо [истина], либо [ложь]) мы можем вычислить. *)

(** **** Упражнение: 1 звезда, стандартное (ltb)

    Функция [ltb] проверяет, меньше ли ([l]ess-[t]han) первый аргумент второго,
    и возвращает логическое значение ([b]).  Вместо того, чтобы объявлять новый
    [Fixpoint] для её вычисления, определите её в терминах ранее определенной
    функции.  (Можно обойтись только одной ранее определенной функцией, но Вы
    можете использовать две, если хотите.) *)

Definition ltb (n m : nat) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Notation "x <? y" := (ltb x y) (at level 70) : nat_scope.

Example test_ltb1:             (ltb 2 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_ltb2:             (ltb 2 4) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_ltb3:             (ltb 4 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Доказательство упрощением *)

(** Теперь, когда мы рассмотрели несколько типов данных и функций, давайте
    перейдем к описанию и доказательству их свойств и поведения.

    На самом деле, мы уже начали это делать: в каждом [Примере] в предыдущих
    разделах было сделано точное утверждение о поведении некоторых функций на
    некоторых конкретных входных данных.  Доказательства этих утверждений
    всегда были одинаковыми: используем [simpl] для упрощения обеих частей
    уравнения, затем используем [reflexivity] для проверки того, что обе части
    содержат одинаковые значения. *)
Example plus_1_1 : 1 + 1 = 2.
Proof. simpl. reflexivity. Qed.

(** Такое "доказательство путем упрощения" может быть использовано для
    установления более интересных свойств.  Например, тот факт, что [0] является
    "нейтральным элементом" для [+] слева, может быть доказан простым
    наблюдением, что [0 + n] сводится к [n] независимо от того, что такое [n] --
    факт, который можно вычитать непосредственно из определения [plus]. *)

Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(** (Вы можете заметить, что приведенное выше утверждение отличается, если
    просматривать файл [.v] в IDE, от HTML-представления в вашем браузере. В
    файлах [.v] мы записываем квантор всеобщности [forall], используя
    зарезервированный идентификатор "forall".  Когда файлы [.v] преобразуются в
    HTML, он преобразуется в стандартный символ "перевёрнутое А".)

    Здесь уместно упомянуть, что [рефлексивность] в Rocq -- это нечто более
    сильное, чем мы заявляли раньше. В примерах, которые мы видели, вызовы
    [simpl] на самом деле не требовались, потому что [reflexivity] автоматически
    выполнит некоторое упрощение при проверке равенства двух сторон; [simpl] был
    добавлен только для того, чтобы мы могли видеть промежуточное состояние
    после упрощения, но перед завершением доказательства.  Вот более короткое
    доказательство: *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(** Более того, будет полезно знать, что [reflexivity] делает несколько
    _большее_ упрощение, чем [simpl] - например, она пытается "развернуть"
    некоторые термины, заменив их на их определения.  Причина этого различия в
    том, что, если [reflexivity] срабатывает, конечная цель достигнута, и нам не
    нужно смотреть на то, какие раскрытые выражения создала [reflexivity]
    благодаря всем этим упрощениям и подстановкам; напротив, [simpl]
    используется в ситуациях, когда нам, возможно, придется прочитать и понять
    новую цель, которую эта команда создаёт, поэтому мы не хотели бы вслепую
    разворачивать определения и оставлять мешанину вместо цели.

    Внешний вид теоремы, которую мы только что сформулировали, и её
    доказательство почти в точности совпадают с более простыми примерами,
    которые мы видели ранее; есть всего лишь несколько отличий.

    Во-первых, мы использовали ключевое слово [Theorem] вместо [Example].
    Это различие в основном зависит от стиля; ключевые слова [Example] и
    [Theorem] (и несколько других, включая [Lemma], [Fact] и [Remark]) означают
    для Rocq практически одно и то же.

    Во-вторых, мы добавили квантор [forall n:nat], так что наша теорема сообщает
    некоторый факт про _все_ натуральные числа [n].  Неформально, чтобы доказать
    теорему такого вида, мы обычно начинаем со слов "Предположим, что [n] -- это
    некоторое число..."  Формально это достигается в доказательстве с помощью
    команды [intros n], которая перемещает [n] из квантора в цели в _контекст_
    текущих предположений.

    Кстати, мы могли бы использовать другой идентификатор вместо [n] в клозе
    [intros] (хотя, конечно, это может сбить с толку людей, читающих
    доказательство): *)

Theorem plus_O_n'' : forall n : nat, 0 + n = n.
Proof.
  intros m. reflexivity. Qed.

(** Ключевые слова [intros], [simpl] и [reflexivity] являются примерами
    _тактик_.  Тактика - это команда, которая используется между [Proof] и [Qed]
    для направления процесса проверки выдвигаемых нами утверждений.  Мы
    рассмотрим еще несколько тактик в оставшейся части этого занятия и многие
    другие в следующих занятиях. *)

(** Другие похожие теоремы можно доказать аналогичным образом. *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** Суффикс [_l] в названиях этих теорем произносится как "слева". *)

(** Стоит ознакомиться с этими доказательствами в интерактивном режиме,
    чтобы увидеть, как меняются контекст и цель.  Возможно, вы захотите добавить
    вызовы [simpl] перед [reflexivity], чтобы увидеть упрощения, которые
    выполняет Rocq в термах, прежде чем проверить их равенство. *)

(* ################################################################# *)
(** * Доказательства переписыванием *)

(** Следующая теорема немного интереснее тех, что мы видели ранее: *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** Вместо общего утверждения обо всех числах [n] и [m] в нем говорится о
    более конкретном свойстве, которое выполняется только тогда, когда [n = m].
    Символ стрелки произносится как "следует".

    Как и прежде, нам нужно уметь рассуждать, предполагая, что нам даны такие
    числа [n] и [m].  Нам также нужно принять гипотезу [n = m]. Тактика
    [intros] поможет перенести все три из них из цели в предположения в текущем
    контексте.

    Поскольку [n] и [m] являются произвольными числами, мы не можем просто
    использовать упрощение для доказательства этой теоремы.  Вместо этого мы
    сначала заметим, что если мы предполагаем, что [n = m], то мы можем заменить
    [n] на [m] в формулировке цели и получить равенство с одинаковым выражением
    с обеих сторон.  Тактика, благодаря которой Rocq выполнит такую замену,
    называется [rewrite]. *)

Proof.
  (* вводим обе переменные в контекст: *)
  intros n m.
  (* перемещаем гипотезу в контекст: *)
  intros H.
  (* переписываем цель с помощью гипотезы: *)
  rewrite -> H.
  reflexivity.  Qed.

(** В первой строке доказательства переменные [n] и [m] перемещаются
    из-под квантора всеобщности в контекст.  Во второй строке гипотеза [n = m]
    помещается в контекст и получает название [H]. Третья указывает Rocq
    переписать текущую цель ([n + n = m + m]), заменив левую часть гипотезы о
    равенстве [H] на правую часть.

    (Символ стрелки в [rewrite] не имеет ничего общего с импликацией: он
    указывает Rocq применить переписывание слева направо. На самом деле, мы
    можем опустить стрелку, и Rocq по умолчанию будет переписывать слева
    направо. Чтобы переписать справа налево, используйте [rewrite <-].
    Попробуйте внести это изменение в приведенное выше доказательство и
    посмотрите, что изменится.) *)
(** **** Упражнение: 1 звезда, стандартное (plus_id_exercise)

    Уберите "[Admitted.]" и завершите доказательство.  (Обратите внимание, что в
    теореме есть две гипотезы -- [n = m] и [m = o] -- каждая слева от стрелки
    импликации.) *)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Команда [Admitted] сообщает Rocq, что мы хотим опустить доказательство
    этой теоремы и просто принять ее как данность.  Это часто полезно для
    разработки более длинных доказательств: мы можем сформулировать
    дополнительные леммы, которые, по нашему мнению, будут полезны для создания
    более сильных аргументов; используем [Admitted], чтобы принять их на веру на
    данный момент; продолжаем работать над основным доказательством, пока мы не
    будем уверены в его осмысленности; затем мы сможем вернуться и дозаполнить
    пропущенные доказательства.

    Однако будьте осторожны: каждый раз, когда ты говоришь, что доказательство
    [Принято], ты оставляешь для полной чепухи открытую настежь дверь в
    прекрасный, строгий, формально проверенный Rocq-ом мир! *)

(** Команду [Check] также можно использовать, чтобы изучить утверждения лемм и
    теорем, объявленных ранее. Ниже мы выясняем, что утверждают две леммы из
    стандартной библиотеки. (В следующий раз мы узнаем, как самим доказывать
    такие леммы.) *)

Check mult_n_O.
(* ===> forall n : nat, 0 = n * 0 *)

Check mult_n_Sm.
(* ===> forall n m : nat, n * m + n = n * S m *)

(** Тактику [rewrite] можно использовать не только с гипотезами из контекста, но
    и с ранее доказанными теоремами. Если при этом в утверждении теоремы
    содержатся кванторы, то, как в примере ниже, Rocq постарается подобрать для
    них подходящие значения с помощью сопоставления утверждения теоремы с
    текущей целью. *)

Theorem mult_n_0_m_0 : forall p q : nat,
  (p * 0) + (q * 0) = 0.
Proof.
  intros p q.
  rewrite <- mult_n_O.
  rewrite <- mult_n_O.
  reflexivity. Qed.

(** **** Упражнение: 1 звезда, стандартное (mult_n_1)

    Используя [mult_n_Sm] и [mult_n_0], докажите следующую теорему.
    (Напомним, [1] это [S O].) *)

Theorem mult_n_1 : forall p : nat,
  p * 1 = p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Доказательство разбором случаев *)

(** Конечно, не всё можно доказать простым вычислением и переписыванием: в
    целом, неизвестные, гипотетические значения (произвольные числа, логические
    значения, списки и т.д.) могут препятствовать упрощению.  Например, если мы
    попытаемся доказать следующий факт, используя [simpl], мы попадаем в тупик.
    (Затем мы используем команду [Abort], чтобы тактически отступить.) *)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n.
  simpl.  (* ничего не делает! *)
Abort.

(** Причина этого в том, что определения как [eqb], так и [+] начинаются с
    сопоставления по образцу для их первого аргумента. Здесь первым аргументом
    для [+] является неизвестное число [n], а аргументом для [eqb] является
    составное выражение [n + 1]; ни то, ни другое не может быть упрощено.

    Чтобы продвинуться вперед, нам нужно рассмотреть возможные случаи
    внутреннего устройства [n] по отдельности.  Если [n] равно [O], то мы можем
    вычислить конечный результат [(n + 1) =? 0] и убедиться, что, действительно,
    он равен [false].  А если [n = S n'] для некоторого [n'], тогда -- хотя мы
    точно не знаем, что из себя представляет число [n + 1] -- мы можем
    вычислить, что, по крайней мере, её запись будет начинаться с единицы [S]; и
    этого достаточно, чтобы вычислить, что, опять же, [(n + 1) =? 0] вернёт
    [false].

    Тактика, которая предписывает Rocq рассматривать отдельно случаи, где
    [n = O] и где [n = S n'], называется [destruct]. *)

Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity.   Qed.

(** [destruct] генерирует _две_ подцели, которые мы затем должны доказать
    по отдельности, чтобы заставить Rocq принять доказательство.

    Аннотация "[as [| n']]" называется _образец для входа_.  Он указывает Rocq,
    какие имена переменных вводить в каждую подцель.  В общем случае, в
    квадратных скобках содержится список списков имен, разделенных символом [|].
    В данном случае первый список пуст, поскольку конструктор [O] не принимает
    никаких аргументов.  Во втором списке содержится единственное имя [n'],
    поскольку [S] является унарным конструктором.

    В каждой подцели Rocq запоминает предположение о [n], которое имеет
    отношение к этой подцели - либо [n = 0], либо [n = S n'] для некоторого n'.
    Аннотация [eqn:E] указывает [destruct] присвоить этому уравнению имя [E].
    (Пропуск аннотации [eqn:E] приведёт к тому, что Rocq устранит эти
    предположения в подцелях.  Это немного упрощает доказательства, в которых
    допущения явно не используются, но лучше оставлять их из соображений
    документации, поскольку они могут помочь вам ориентироваться при работе с
    подцелями.)

    Знаки [-] во второй и третьей строках называются "буллетами", и они
    обозначают части доказательства, соответствующие двум сгенерированным
    подцелям.  Часть скрипта, которая следует за маркером -- это полное
    доказательство для соответствующей подцели.  В этом примере каждая из
    подцелей легко доказывается с помощью единственного вызова [reflexivity],
    которая сама по себе обеспечивает некоторое упрощение -- например, второй
    вызов упрощает [(S n' + 1) =? 0] до [false], сначала переписывая
    [(S n' + 1)] на [S (n' + 1)], затем разворачивая [eqb], и, наконец, упрощая
    [match].

    Отмечать отдельные случаи маркерами необязательно: если маркеров нет, Rocq
    просто ожидает, что вы будете доказывать каждую подцель последовательно, по
    одной за раз. Но рекомендуется использовать маркеры.  Во-первых, они
    упрощают структуру доказательства, улучшая читаемость. Кроме того, маркеры
    указывают Rocq, что перед проверкой следующей подцели необходимо убедиться в
    том, что подцель выполнена, что предотвращает смешение доказательств для
    разных подцелей. Эти детали становятся особенно важными в более крупных
    разработках, где хрупкие доказательства могут привести к длительному
    процессу отладки!

    В Rocq не существует жестких правил оформления доказательств -- например,
    где следует прерывать строки и какие отступы должны быть у разделов
    доказательства, чтобы показать его вложенную структуру.  Однако, если места,
    где генерируется несколько подцелей, помечены четкими маркерами в начале
    строки, то доказательство будет читаемым практически независимо от того,
    какие решения будут приняты в отношении других аспектов компоновки.

    Здесь также уместно упомянуть еще один довольно очевидный совет по поводу
    длины строк.  Начинающие пользователи Rocq иногда бросаются в крайности и
    либо пишут каждую тактику отдельно, либо пытаются уместить всё
    доказательство в одну строчку.  Хороший стиль находится где-то посередине.
    Например, разумной рекомендацией является ограничение в 80 (или, если у вас
    широкий экран либо хорошие глаза, 120) символов в строчке.

    Тактика [destruct] может быть использована с любым индуктивным типом данных.
    Например, мы используем его далее, чтобы доказать, что булево отрицание
    инволютивно, т.е. обратно самому себе. *)

Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity.  Qed.

(** Обратите внимание, что здесь в [destruct] нет клозы [as], потому что
    ни в одном из случаев [destruct] не требуется создавать какие-либо
    переменные, поэтому нет необходимости указывать какие-либо имена.  На самом
    деле, мы можем опустить клозу [as] из _любого_ вызова [destruct], и Rocq
    заполнит имена переменных автоматически.  Правда, это считается дурным
    тоном, поскольку Rocq чаще всего выбирает имена крайне неудачно.

    Иногда полезно вызвать [destruct] внутри подцели, создавая еще больше
    подцелей. В этом случае мы используем различные виды буллетов для
    обозначения целей на разных "уровнях". Например: *)

Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.

(** Каждая пара вызовов [reflexivity] соответствует подцелям, которые были
    сгенерированы после исполнения строчек с [destruct c] прямо над ними. *)

(** Помимо [-] и [+], в качестве буллета можно использовать [*] (астериск),
    а также любое их повторение (например, [--], [***]).  Также вместо
    использования буллетов мы можем заключать части доказательства в фигурные
    скобки: *)

Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.

(** Раз фигурные скобки помечают и начало, и конец доказательства, их можно
    использовать на любом уровне вложенности. Более того, внутри фигурных скобок
    можно снова использовать те же буллеты, что использовались на уровнях выше.

    Как можно заметить, использование буллетов и скобок -- чисто вопрос вкуса.
*)

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
  - destruct c eqn:Ec.
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
    { destruct d eqn:Ed.
      - reflexivity.
      - reflexivity. }
Qed.

(** **** Упражнение: 2 звезды, стандартное (andb_true_elim2)

    Докажите следующее утверждение, отмечая случаи (и под-случаи) с помощью
    буллетов, когда вы используете [destruct].

    Подсказка 1: до сих пор мы использовали [simpl] только для упрощения цели.
    Но её можно использовать и для упрощения гипотез: используйте [simpl in H],
    где [H] -- гипотеза, чтобы упростить её. Возможно, это пригодится Вам при
    выполнении упражнения.

    Подсказка 2: В конечном итоге вам нужно будет разобрать по случаям оба
    логических значения, как в приведенных выше теоремах. Но лучше отложить ввод
    гипотезы до тех пор, пока у вас не появится возможность упростить ее.

    Подсказка 3: Когда вы обнаружите противоречие в гипотезах, сосредоточьтесь
    на том, как [переписать] это противоречие. *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Прежде чем подытожить первую лекцию, давайте упомянем еще об одном
    удобстве.  Как вы, возможно, заметили, во многих доказательствах выполняется
    разбор случаев для переменной сразу после ее введения:

       intros x y. destruct y as [|y] eqn:E.

    Этот паттерн настолько распространен, что Rocq предоставляет для него
    сокращение: мы можем выполнить разбор случаев для переменной при её
    введении, используя образец вместо имени переменной. Например, вот более
    краткое доказательство теоремы [plus_1_neq_0] выше.  (Также
    заметьте один недостаток этого сокращения: мы теряем предположение, которое
    мы делали в каждой из подцелей, которые мы ранее получали из аннотации
    [eqn:E].) *)

Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.

(** Если у конструкторов нет полей, которые нужно называть, можно использовать
    просто [[]], чтобы получить разбор случаев. *)

Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

(** **** Упражнение: 1 звезда, стандартное (zero_nbeq_plus_1) *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  0 =? (n + 1) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Подробнее о нотации (необязательно) *)

(** (Как правило, разделы, помеченные как необязательные, не нужны для
    ознакомления с остальными материалами курса, за исключением, возможно,
    других необязательных разделов.  При первом чтении вы можете просто
    проглядеть эти разделы, чтобы знать, что в них, и вернуться позднее.)

    Вспомним определения обозначений для инфиксных плюса и умножения: *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

(** Для каждой нотации в Rocq мы можем указать её _приоритет_ и
    _ассоциативность_.  Приоритет [n] указывается записью [at level n]; это
    помогает Rocq считывать составные выражения.  Ассоциативность же помогает
    устранить неоднозначность выражений, содержащих несколько повторений одного
    и того же символа. Например, параметры, указанные выше для [+] и [*],
    говорят о том, что выражение [1+2*3*4] является сокращением для
    [(1+((2*3)*4))]. Rocq использует приоритеты от 0 до 100 и _левую_ ([left]),
    _правую_ ([right]) или _никакую_ ([no]) ассоциативность.  Мы увидим больше
    примеров позже, например, когда будем работать со списками.

    Каждая нотация также связана со своей _областью видимости_. Rocq пытается
    угадать используемую область из контекста, поэтому, когда он видит
    [S (O*O)], он угадывает [nat_scope], но когда он видит пару [bool*bool]
    (которую мы увидим позднее), он угадывает [type_scope].  Иногда необходимо
    помочь ему, написав, например, [(x*y)%nat]; иногда и сам Rocq при печати
    использует [%nat], чтобы указать, из какой области берётся та или иная
    нотация.

    Области видимости также применяются к цифровым обозначениям ([3], [4], [5],
    [42], и т.д.), поэтому иногда вы увидите [0%nat], что означает [O]
    (натуральное число [0], которое мы используем в этой главе) или [0%Z], что
    означает целое число, равное нулю (которое взято из другой части стандартной
    библиотеки).

    Pro tip: механизм нотаций в Rocq не особенно мощный. Не ждите от него
    слишком многого. *)

(* ================================================================= *)
(** ** Неподвижные точки и структурная рекурсия (необязательно) *)

(** Вот копия определения сложения: *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus' n' m)
  end.

(** Когда Rocq проверяет это определение, он замечает, что [plus'] "уменьшается
    в первом аргументе".  Это означает, что мы выполняем _структурную рекурсию_
    по аргументу [n], т.е. мы выполняем рекурсивные вызовы только для строго
    меньших значений [n].  Это означает, что все вызовы [plus'] в конечном итоге
    завершатся.  Rocq требует, чтобы некоторый аргумент определения _каждой_
    [Неподвижной точки] был "убывающим".

    Это требование является фундаментальной особенностью дизайна Rocq: в
    частности, оно гарантирует, что каждая функция, которая может быть
    определена в Rocq, завершится на всех входных данных.  Однако, поскольку
    "анализ убывания" в Rocq не очень сложен, иногда приходится писать функции
    несколько неестественным образом. *)

(** **** Упражнение: 2 звезды, стандартное, по желанию (decreasing)

    Чтобы ощутить это, найдите способ написать разумное определение [Fixpoint]
    (например, простой функции для чисел), которое _завершается_ на всех входных
    данных, но которое Rocq отклоняет из-за своих ограничений.

    (Если вы решите включить это необязательное упражнение в домашнее задание,
    обязательно закомментируйте свое решение, чтобы Rocq не отклонил весь файл
    целиком!) *)

(* ЗАПОЛНИТЕ ЗДЕСЬ

    [] *)

(* ################################################################# *)
(** * Больше упражнений *)

(* ================================================================= *)
(** ** Разминка *)

(** **** Упражнение: 1 звезда, стандартное (identity_fn_applied_twice)

    Используйте тактики, которые вы освоили на данный момент, в доказательстве
    следующей теоремы о булевых функциях. *)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
  (forall (x : bool), f x = x) ->
  forall (b : bool), f (f b) = b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 1 звезда, стандартное (negation_fn_applied_twice)

    Теперь сформулируйте и докажите теорему [negation_fn_applied_twice],
    аналогичную предыдущей, но в которой вторая гипотеза гласит, что
    функция [f] обладает свойством, что [f x = negb x]. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_negation_fn_applied_twice : option (nat*string) := None.
(** (Определение выше используется при автопроверке.)

    [] *)

(** **** Упражнение: 3 звезды, стандартное, по желанию (andb_eq_orb)

    Докажите следующую теорему.  (Подсказка: это может быть немного сложно, в
   зависимости от того, как вы подойдёте к доказательству.  Вероятно, вам
   понадобятся и [destruct] и [rewrite], но [уничтожать] все, что попадается на
   глаза -- не лучший подход.) *)

Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) ->
  b = c.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ================================================================= *)
(** ** Сдача после дедлайна: формализация *)

(** Предположим, что на некотором курсе действует политика выставления оценок,
    основанная на опозданиях, при которой итоговая оценка студента по системе
    A-B-C-D-F снижается, если он сдает слишком много домашних заданий с
    опозданием.

    В следующей серии задач мы смоделируем эту ситуацию, используя средства
    Rocq, которые мы видели до сих пор, и докажем некоторые простые факты
    об этой политике выставления оценок.  *)

Module LateDays.

(** Сначала мы вводим тип данных для моделирования "буквенной" части оценки. *)
Inductive letter : Type :=
  | A | B | C | D | F.

(** Затем мы определяем модификаторы: [Natural] [A] это просто "обычная" оценка
    [A]. *)
Inductive modifier : Type :=
  | Plus | Natural | Minus.

(** Тогда полная [оценка] - это просто [буква] и [модификатор].

    Неформально мы могли бы написать "A-" вместо [Grade A Minus] и, аналогично,
    "C" вместо [Grade C Natural]. *)
Inductive grade : Type :=
  Grade (l:letter) (m:modifier).

(** Мы захотим иметь возможность определить, когда одна оценка "лучше" другой.
    Другими словами, нам нужен способ сравнить две оценки.  Как и в случае с
    натуральными числами, мы могли бы определить функции, имеющие логическое
    значение [grade_eqb], [grade_ltb] и т.д., и это будет работать нормально.
    Однако мы также можем определить немного более информативный тип для
    сравнения двух значений, как показано ниже.  Этот тип данных имеет три
    конструктора, которые можно использовать для указания того, являются ли два
    значения "равными", "меньше" или "больше" друг друга. (Это определение также
    содержится в стандартной библиотеке Rocq.)  *)

Inductive comparison : Type :=
  | Eq         (* равно, "equal" *)
  | Lt         (* меньше чем, "less than" *)
  | Gt.        (* больше чем, "greater than" *)

(** Используя сопоставление с образцом, нетрудно определить операцию сравнения
    для двух букв [l1] и [l2] (см. ниже). В этом определении используются две
    особенности сопоставления с образцом: во-первых, напомним, что мы можем
    сопоставлять одновременно два значения, разделяя их и соответствующие
    образцы запятой [,]. Это просто удобное сокращение для вложенного
    сопоставления.  Например, сопоставление слева ниже это просто сокращение для
    более низкоуровневой "расширенной версии", показанной справа:

  match l1, l2 with          match l1 with
  | A, A => Eq               | A => match l2 with
  | A, _ => Gt                      | A => Eq
  end                               | _ => Gt
                                    end
                             end
*)
(** Мы также можем сопоставить сразу несколько образцов, используя [|].
    Например, образец [C , (A | B)] захватывает сразу два случая:
    [C, A] и [C, B]. *)

Definition letter_comparison (l1 l2 : letter) : comparison :=
  match l1, l2 with
  | A, A => Eq
  | A, _ => Gt
  | B, A => Lt
  | B, B => Eq
  | B, _ => Gt
  | C, (A | B) => Lt
  | C, C => Eq
  | C, _ => Gt
  | D, (A | B | C) => Lt
  | D, D => Eq
  | D, _ => Gt
  | F, (A | B | C | D) => Lt
  | F, F => Eq
  end.

(** Мы можем протестировать операцию [letter_comparison], опробовав ее на
    нескольких примерах. *)
Compute letter_comparison B A.
(** ==> Lt *)
Compute letter_comparison D D.
(** ==> Eq *)
Compute letter_comparison B F.
(** ==> Gt *)

(** В качестве дополнительной проверки на разумность мы можем доказать, что
    функция [letter_comparison] действительно выдает результат [Eq] при
    сравнении буквы [l] с самой собой.  *)
(** **** Упражнение: 1 звезда, стандартное (letter_comparison) *)
Theorem letter_comparison_Eq :
  forall l, letter_comparison l l = Eq.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Мы можем следовать той же стратегии, чтобы определить операцию сравнения
    для двух модификаторов оценки.  Мы считаем, что они должны быть упорядочены
    следующим образом: [Plus > Natural > Minus]. *)
Definition modifier_comparison (m1 m2 : modifier) : comparison :=
  match m1, m2 with
  | Plus, Plus => Eq
  | Plus, _ => Gt
  | Natural, Plus => Lt
  | Natural, Natural => Eq
  | Natural, _ => Gt
  | Minus, (Plus | Natural) => Lt
  | Minus, Minus => Eq
  end.

(** **** Упражнение: 2 звезды, стандартное (grade_comparison)

    Используйте сопоставление с образцом для завершения следующего определения.

    (Такое упорядочение оценок иногда называют "лексикографическим" порядком:
    сначала мы сравниваем буквы, а модификаторы учитываем только в том случае,
    если буквы равны.  Т.е. все варианты оценки [A] лучше, чем все варианты
    [B].)

    Подсказка: сопоставляйте [g1] и [g2] одновременно, но не пытайтесь
    перечислить все варианты.  Вместо этого проведите разбор случаев для
    результата подходящего вызова [letter_comparison], чтобы в итоге получить
    только [3] варианта. *)

Definition grade_comparison (g1 g2 : grade) : comparison
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Следующие "юнит-тесты" вашей функции [grade_comparison] должны пройти,
    как только вы правильно ее определите. *)

Example test_grade_comparison1 :
  (grade_comparison (Grade A Minus) (Grade B Plus)) = Gt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison2 :
  (grade_comparison (Grade A Minus) (Grade A Plus)) = Lt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison3 :
  (grade_comparison (Grade F Plus) (Grade F Plus)) = Eq.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_grade_comparison4 :
  (grade_comparison (Grade B Minus) (Grade C Plus)) = Gt.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Теперь, когда у нас есть определение оценок и то, как они соотносятся
    друг с другом, давайте реализуем функцию штрафа за опоздание. *)

(** Сначала мы определяем, что значит понизить [буквенный] компонент оценки.
    Поскольку [F] уже является самой низкой из возможных оценок, мы просто
    оставляем её без изменений.  *)
Definition lower_letter (l : letter) : letter :=
  match l with
  | A => B
  | B => C
  | C => D
  | D => F
  | F => F  (* Нельзя получить меньше [F]! *)
  end.

(** Наша формализация уже может помочь нам понять некоторые важные крайние
    случаи в нашей политике выставления оценок.  Например, мы могли бы ожидать,
    что если мы используем функцию [lower_letter], то ее результат действительно
    будет ниже, как утверждается в следующей теореме.  Но эта теорема
    недоказуема!  (Вы понимаете почему?) *)
Theorem lower_letter_lowers: forall (l : letter),
  letter_comparison (lower_letter l) l = Lt.
Proof.
  intros l.
  destruct l.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. reflexivity.
  - simpl. (* Здесь-то мы и застряли. *)
Abort.

(** Проблема, конечно же, связана с "крайним случаем" понижения
    [F], в чём мы можем убедиться следующим образом: *)
Theorem lower_letter_F_is_F:
  lower_letter F = F.
Proof.
  simpl. reflexivity.
Qed.

(** Вооружившись новым знанием, мы можем сформулировать улучшенную версию
    теоремы, которая уже будет доказуема.  В этой версии гипотеза о [F] гласит,
    что [F] строго меньше, чем [l], что исключает проблемный случай, описанный
    выше. Другими словами, до тех пор, пока [l] больше, чем [F], оно будет
    уменьшаться. *)
(** **** Упражнение: 2 звезды, стандартное (lower_letter_lowers)

    Докажите следующую теорему. *)

Theorem lower_letter_lowers:
  forall (l : letter),
    letter_comparison F l = Lt ->
    letter_comparison (lower_letter l) l = Lt.
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 2 звезды, стандартное (lower_grade)

    Теперь мы можем использовать определение [lower_letter] в качестве
    вспомогательного средства для определения того, что значит понизить оценку
    на одну ступень.  Заполните приведенное ниже определение так, чтобы оно
    понизило оценку [g] на одну ступень (если только это уже не [оценка F с
    минусом], которая должна остаться неизменной).  Как только вы правильно ее
    реализуете, последующие "юнит-тесты" должны выполняться без ошибок.

    Подсказка: Чтобы это определение было кратким, чтобы его свойства было легко
    доказывать, вы, вероятно, захотите использовать вложенное сопоставление с
    образцом. Внешний [match] не должен производить сопоставление с буквенной
    частью оценки -- он должен учитывать только модификатор. _Не стоит_ пытаться
    перечислить все случаи.

    Наше решение содержит менее 10 строк кода. *)
Definition lower_grade (g : grade) : grade
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example lower_grade_A_Plus :
  lower_grade (Grade A Plus) = (Grade A Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_A_Natural :
  lower_grade (Grade A Natural) = (Grade A Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_A_Minus :
  lower_grade (Grade A Minus) = (Grade B Plus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_B_Plus :
  lower_grade (Grade B Plus) = (Grade B Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_F_Natural :
  lower_grade (Grade F Natural) = (Grade F Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_twice :
  lower_grade (lower_grade (Grade B Minus)) = (Grade C Natural).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example lower_grade_thrice :
  lower_grade (lower_grade (lower_grade (Grade B Minus))) = (Grade C Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Rocq не различает [Примеры] и [Теоремы]. Мы формулируем нижеследующее как
    [Теорему] только в качестве намека на то, что мы будем использовать это
    утверждение в доказательствах ниже. *)
Theorem lower_grade_F_Minus : lower_grade (Grade F Minus) = (Grade F Minus).
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(* GRADE_THEOREM 0.25: lower_grade_A_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_A_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_A_Minus *)
(* GRADE_THEOREM 0.25: lower_grade_B_Plus *)
(* GRADE_THEOREM 0.25: lower_grade_F_Natural *)
(* GRADE_THEOREM 0.25: lower_grade_twice *)
(* GRADE_THEOREM 0.25: lower_grade_thrice *)
(* GRADE_THEOREM 0.25: lower_grade_F_Minus

    [] *)

(** **** Упражнение: 3 звезды, стандартное (lower_grade_lowers)

    Докажите следующую теорему, которая гласит, что до тех пор, пока оценка
    начинается выше F-, [lower_grade] действительно понижает оценку.  Как
    обычно, разрушать все, что попадается на глаза -- _плохая_ идея.
    Разумное использование [destruct] вместе с переписыванием -- это уже
    стратегия получше.

    Подсказка: Если вы определили свою функцию [grade_comparison] так, как было
    предложено, вам нужно будет использовать [rewrite], используя
    [letter_comparison_Eq], в двух случаях.  Последний случай -- единственный,
    в котором вам нужно деструктировать [букву].  В случае для [F], вероятно,
    пригодится [lower_grade_F_Minus]. *)
Theorem lower_grade_lowers :
  forall (g : grade),
    grade_comparison (Grade F Minus) g = Lt ->
    grade_comparison (lower_grade g) g = Lt.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Теперь, когда мы реализовали и протестировали функцию, которая снижает
    оценку на одну ступень, мы можем внедрить специальную политику в отношении
    работ, сданных после дедлайна. При заданном количестве дней опоздания
    ([late_days]) функция [apply_late_policy] вычисляет итоговую оценку на
    основе [g], начальной оценки.

    Эта функция кодирует следующую политику:

      # дней опоздания     штраф
         0 - 8             штрафов нет
         9 - 16            понизить оценку на одну ступень (A+ => A и т.д.)
        17 - 20            понизить оценку на две ступени
          >= 21            понизить оценку на три ступени (на целую букву)
*)
Definition apply_late_policy (late_days : nat) (g : grade) : grade :=
  if late_days <? 9 then g
  else if late_days <? 17 then lower_grade g
  else if late_days <? 21 then lower_grade (lower_grade g)
  else lower_grade (lower_grade (lower_grade g)).

(** Иногда полезно уметь "разворачивать" определение, чтобы иметь возможность
    продвинуться в доказательстве.  Вскоре мы увидим, как сделать это гораздо
    более простым способом автоматически, но пока легко доказать, что
    использование любого определения вроде [apply_late_policy] равно его правой
    части, просто используя рефлексивность.

    Этот результат полезен, поскольку позволяет нам использовать [rewrite] для
    раскрытия внутренней части определения. *)
Theorem apply_late_policy_unfold :
  forall (late_days : nat) (g : grade),
    (apply_late_policy late_days g)
    =
    (if late_days <? 9 then g  else
       if late_days <? 17 then lower_grade g
       else if late_days <? 21 then lower_grade (lower_grade g)
            else lower_grade (lower_grade (lower_grade g))).
Proof.
  intros. reflexivity.
Qed.

(** Теперь давайте докажем некоторые свойства этой политики. *)

(** Следующая теорема гласит, что если ученик набирает не более восьми дней
    опоздания, его оценка за семестр не меняется. Это легко доказать: как только
    Вы используете [apply_late_policy_unfold], можно переписать оставшуюся цель,
    используя гипотезу. *)

(** **** Упражнение: 2 звезды, стандартное (no_penalty_for_mostly_on_time) *)
Theorem no_penalty_for_mostly_on_time :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = true) ->
    apply_late_policy late_days g = g.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** Следующая теорема гласит, что если ученик накапливает от 9 до 16 дней
    опозданий, его итоговая оценка снижается на одну ступень. *)

(** **** Упражнение: 2 звезды, стандартное (graded_lowered_once) *)
Theorem grade_lowered_once :
  forall (late_days : nat) (g : grade),
    (late_days <? 9 = false) ->
    (late_days <? 17 = true) ->
    (apply_late_policy late_days g) = (lower_grade g).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)
End LateDays.

(* ================================================================= *)
(** ** Двоичные нумералы *)

(** **** Упражнение: 3 звезды, стандартное (binary)

    Мы можем обобщить наше унарное представление натуральных чисел до более
    эффективного двоичного представления, рассматривая двоичное число как
    последовательность конструкторов [B0] и [B1] (представляющих 0s и 1s),
    заканчивающихся [Z]. Для сравнения, в унарном представлении число -- это
    последовательность конструкторов [S], заканчивающаяся символом [O].

    Например:

      десятичная               двоичная                        унарная
           0                       Z                              O
           1                    B1 Z                            S O
           2                B0 (B1 Z)                        S (S O)
           3                B1 (B1 Z)                     S (S (S O))
           4            B0 (B0 (B1 Z))                 S (S (S (S O)))
           5            B1 (B0 (B1 Z))              S (S (S (S (S O))))
           6            B0 (B1 (B1 Z))           S (S (S (S (S (S O)))))
           7            B1 (B1 (B1 Z))        S (S (S (S (S (S (S O))))))
           8        B0 (B0 (B0 (B1 Z)))    S (S (S (S (S (S (S (S O)))))))

    Обратите внимание, что младший бит расположен слева, а старший справа, в
    отличие от обычного способа записи двоичных чисел.  Такой выбор упрощает
    работу с ними.

    (Вопрос на понимание: какой унарный нумерал соответствует [B0 Z]?) *)

Inductive bin : Type :=
  | Z
  | B0 (n : bin)
  | B1 (n : bin).

(** Завершите приведенные ниже определения функции инкремента [inc]
    для двоичных чисел и функции [bin_to_nat] для преобразования
    двоичных чисел в унарные. *)

Fixpoint incr (m:bin) : bin
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Fixpoint bin_to_nat (m:bin) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Следующие "юнит-тесты" ваших функций инкремента и преобразования двоичного
    кода в унарный должны выполняться успешно после того, как вы правильно
    определили эти функции. Конечно, модульные тесты не в полной мере
    демонстрируют корректность ваших функций!  Мы вернемся к этой мысли в конце
    следующей главы. *)

Example test_bin_incr1 : (incr (B1 Z)) = B0 (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr2 : (incr (B0 (B1 Z))) = B1 (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr3 : (incr (B1 (B1 Z))) = B0 (B0 (B1 Z)).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr4 : bin_to_nat (B0 (B1 Z)) = 2.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr5 :
        bin_to_nat (incr (B1 Z)) = 1 + bin_to_nat (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr6 :
        bin_to_nat (incr (incr (B1 Z))) = 2 + bin_to_nat (B1 Z).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_bin_incr7 : bin_to_nat (B0 (B0 (B0 (B1 Z)))) = 8.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(* ################################################################# *)
(** * Самопроверка решений *)

(** К каждому занятию прилагается тестовый файл, содержащий скрипты, которые
    проверяют, выполнили ли вы необходимые упражнения. Они же запускаются в CI
    для автоматической оценки Ваших решений. Вы также можете использовать эти
    тестовые файлы, если хотите убедиться, что вы ничего не пропустили.

    Важно: Этот шаг является необязательным: если вы выполнили все
    необязательные упражнения и Rocq принял ваши ответы, то уже это показывает,
    что вы находитесь в отличной форме.

    Тестовый файл для этого занятия называется [BasicsTest.v]. Чтобы запустить
    его, убедитесь, что вы сохранили [Basics.v] на диск.  Сперва запустите
    [coqc -Q . Lectures Basics.v] , а затем
    [coqc -Q . Lectures BasicsTest.v]; или, если у вас установлен make, вы
    можете запустить [make BasicsTest.vo]. (Убедитесь, что
    вы делаете это в каталоге, который также содержит файл с именем
    [_CoqProject], содержащий одну строку [-Q . Lectures].)

    Если Вы случайно удалили упражнение или изменили его название, то
    [make BasicsTest.vo] завершится ошибкой, в которой будет указано название
    отсутствующего упражнения.  В противном случае вы получите много полезной
    информации:

    - Сначала будут представлены все результаты, полученные самим [Basics.v].
      В конце вы увидите [COQC BasicsTest.v].

    - Во-вторых, для каждого обязательного упражнения будет выведен отчет, в
      котором сообщается его сложность (количество звезд или какая-то дробь,
      если упражнение состоит из нескольких частей), правильный ли у него тип и
      на какие предположения он опирается.

      Если _тип_ не [ok], это означает, что вы доказали неправильную вещь:
      скорее всего, вы случайно изменили утверждение теоремы во время
      доказательства.  В этом случае автогрейдер не начислит вам никаких баллов,
      поэтому обязательно исправьте теорему.

      _Предположения_ -- это любые недоказанные теоремы, на которые ваше решение
      полагается.  "Closed under the global context" -- это причудливый способ
      сказать "нет": вы решили упражнение. (Ура!)  С другой стороны, список
      аксиом означает, что вы еще не решили их полностью упражнение. (Но
      смотрите ниже раздел "Допустимые аксиомы".) Если само название упражнения
      есть в списке, это означает, что вы его не выполнили; вероятно, вы его
      приняли на веру ([Admitted]).

    - В-третьих, вы увидите максимальное количество баллов в стандартной и
      расширенной версиях задания.  Это число основано на количестве звёзд в
      обязательных упражнениях.  (В данном файле нет продвинутых упражнений.)

    - В-четвертых, вы увидите список "Разрешённых аксиом".  Это недоказанные
      теоремы, от которых может зависеть ваше решение, помимо фундаментальных
      аксиом логики Rocq-а.  Возможно, вы увидите что-то о [функциональной
      экстенсиональности] для этого занятия; мы вскоре рассмотрим, что это
      значит.

    - Наконец, вы увидите сводную информацию о том, решили ли вы каждое из
      упражнений.  Обратите внимание, что краткое изложение не включает
      критическую информацию о том, подходит ли данный тип (то есть, не изменили
      ли вы формулировку теоремы): вы должны посмотреть эту информацию выше.

    Упражнения, которые оцениваются вручную, также будут отображаться в выводе.
    Но поскольку они должны оцениваться человеком, скрипт не сможет ничего о них
    рассказать. *)

(* 2026-02-08 16:15 *)
