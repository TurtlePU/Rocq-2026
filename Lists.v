(** * Списки: Работа со структурированными данными *)

From Lectures Require Export Induction.
Module NatList.

(* ################################################################# *)
(** * Пары натуральных чисел *)

(** В определении [Индуктивного] типа данных каждый конструктор может
    принимать любое количество аргументов -- ни одного (как [true] и [O]), один
    (как [S]) или больше одного (как [nybble] и как следующий конструктор): *)

Inductive natprod : Type :=
  | pair (n1 n2 : nat).

(** Это объявление можно прочитать так: "Единственный способ
    сконструировать пару чисел -- применить конструктор [pair] к двум аргументам
    типа [nat]." *)

Check (pair 3 5) : natprod.

(** Функции для извлечения первой и второй компонент пары можно определить
    через сопоставление с образцом. *)

Definition fst (p : natprod) : nat :=
  match p with
  | pair x y => x
  end.

Definition snd (p : natprod) : nat :=
  match p with
  | pair x y => y
  end.

Compute (fst (pair 3 5)).
(* ===> 3 *)

(** В дальнейшем мы будем активно использовать эти определения,
    так что нам было бы удобно записывать их в стандартной математической
    нотации как [(x,y)] вместо [pair x y].  Мы можем сообщить Rocq об этом
    с помощью объявления новой [Нотации]. *)

Notation "( x , y )" := (pair x y).

(** Нотации можно использовать как в выражениях,
    так и в сопоставлениях с образцом. *)

Compute (fst (3,5)).

Definition fst' (p : natprod) : nat :=
  match p with
  | (x,y) => x
  end.

Definition snd' (p : natprod) : nat :=
  match p with
  | (x,y) => y
  end.

Definition swap_pair (p : natprod) : natprod :=
  match p with
  | (x,y) => (y,x)
  end.

(** Обратите внимание, что сравнение пары с образцом (со скобками: [(x, y)])
    не нужно путать с синтаксисом "мультипаттерна" (без скобок: [x, y]), который
    мы видели ранее.  Примеры выше иллюстрируют сопоставление с образцом
    _единственной_ пары, состоящей из элементов [x] и [y], когда как, например,
    определение [minus] в [Basics] сопоставляет с образцом _два_ значения,
    [n] и [m]:

       Fixpoint minus (n m : nat) : nat :=
         match n, m with
         | O   , _    => O
         | S _ , O    => n
         | S n', S m' => minus n' m'
         end.

    Различие не слишком большое, но важно понимать, что это не одно и то же.
    Например, следующие примеры составлены неправильно:

        (* Нельзя сопоставлять _одну_ пару с мультипаттерном: *)
        Definition bad_fst (p : natprod) : nat :=
          match p with
          | x, y => x
          end.

        (* Нельзя сопоставить _несколько_ значений с помощью _одного_ паттерна
           для пар: *)
        Definition bad_minus (n m : nat) : nat :=
          match n, m with
          | (O   , _   ) => O
          | (S _ , O   ) => n
          | (S n', S m') => bad_minus n' m'
          end.
*)

(** Если мы будем формулировать свойства пар несколько обходным путём, мы иногда
    сможем завершить их доказательства лишь с помощью [рефлексивности] и
    встроенных упрощений: *)

Theorem surjective_pairing' : forall (n m : nat),
  (n,m) = (fst (n,m), snd (n,m)).
Proof.
  reflexivity. Qed.

(** Однако просто [рефлексивности] недостаточно, если мы сформулируем
    утверждение леммы естественным образом: *)

Theorem surjective_pairing_stuck : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  simpl. (* Ничего не упрощает! *)
Abort.

(** Вместо этого, нам нужно обнажить внутреннее устройство [p], чтобы
    [simpl] мог произвести сопоставление с образцом в [fst] и [snd].  Мы можем
    достичь этого с помощью [destruct]. *)

Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p. destruct p as [n m]. simpl. reflexivity. Qed.

(** Обратите внимание, что, в отличие от поведения [destruct]
    на натуральных числах, где он генерирует две подцели, здесь [destruct]
    генерирует всего одну-единственную подцель.  Это происходит ровно потому,
    что [natprod] можно построить единственным способом -- вызовом его
    единственного конструктора. *)

(** **** Упражнение: 1 звезда, стандартное (snd_fst_is_swap) *)
Theorem snd_fst_is_swap : forall (p : natprod),
  (snd p, fst p) = swap_pair p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное, по желанию (fst_swap_is_snd) *)
Theorem fst_swap_is_snd : forall (p : natprod),
  fst (swap_pair p) = snd p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Списки натуральных чисел *)

(** Обобщая определение пар, мы можем описать тип _списков_ чисел
    следующим образом: "Список либо пустой, либо является парой из первого
    элемента (в данном случае числа) и списка, состоящего из остальных
    элементов." *)

Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).

(** Вот, например, список из трёх элементов: *)

Definition mylist := cons 1 (cons 2 (cons 3 nil)).

(** Как и с парами, нам будет удобно записывать списки, используя
    знакомую нотацию.  Следующие объявления позволяют нам использовать [::] в
    качестве инфиксной версии оператора [cons], а квадратные скобки -- в
    качестве "аутфиксной" нотации для построения списков. *)

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(** Разбираться во внутреннем устройстве этих объявлений не обязательно,
    но если Вам интересно, вот что примерно происходит. Аннотация "[right
    associativity]" сообщает Rocq, как расставлять скобки в выражениях,
    содержащих несколько использований [::], так, чтобы, например, следующие три
    объявления значили в точности одно и то же: *)

Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1;2;3].

(** Часть с "[at level 60]" сообщает Rocq, как расставлять скобки
    в выражениях, содержащих и [::], и ещё какой-то другой инфиксный оператор.
    Например, раз мы определили [+] в качестве инфиксной нотации для функции
    [plus] с приоритетом 50,

  Notation "x + y" := (plus x y) (at level 50, left associativity).

    оператор [+] будет _связывать сильнее, чем_ [::], так что [1 + 2 :: [3]]
    будет пониматься как [(1 + 2) :: [3]], как и ожидается, а не как
    [1 + (2 :: [3])].

    (Выражения вида "[1 + 2 :: [3]]" могут слегка озадачить, особенно если
    читать их в файле [.v].  Внутренние скобки, вокруг 3, маркируют список,
    а вот внешние скобки, невидимые при просмотре HTML-версии, направляют
    инструмент "rocq doc" так, чтобы часть в этих скобках отображалась как код
    на Rocq, а не как обычный текст.)

    Второе и третье объявления [Notation] выше вводят стандартную нотацию
    для списков через квадратные скобки; часть справа от [:=] в третьем правиле
    иллюстрирует синтаксис Rocq для объявления нотаций переменной длины и
    их перевода во вложенные последовательности бинарных конструкторов.

    Опять же, не переживайте, если Вас озадачили какие-то детали
    синтаксического анализа: все используемые в нашем курсе нотации
    уже будут определены в лекционных файлах. *)

(* ----------------------------------------------------------------- *)
(** *** Повтор элемента *)

(** Далее, давайте рассмотрим несколько функций для работы со списками.
    Вот, во-первых, функция [repeat], по значению [n] и счётчику [count]
    возвращающая список длины [count], в котором каждый элемент равен [n]. *)

Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.

(* ----------------------------------------------------------------- *)
(** *** Длина списка *)

(** Функция [length] вычисляет длину списка. *)

Fixpoint length (l:natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.

(* ----------------------------------------------------------------- *)
(** *** Конкатенация *)

(** Функция [app] конкатенирует (соединяет) два списка. *)

Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil    => l2
  | h :: t => h :: (app t l2)
  end.

(** Т.к. [app] мы будем использовать очень часто, будет полезно определить
    для её использования инфиксный оператор. *)

Notation "x ++ y" := (app x y)
                     (right associativity, at level 60).

Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].
Proof. reflexivity. Qed.
Example test_app2:             nil ++ [4;5] = [4;5].
Proof. reflexivity. Qed.
Example test_app3:             [1;2;3] ++ nil = [1;2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Голова и хвост *)

(** Ещё две простейших функции для работы со списками. Функция [hd]
    возвращает первый элемент ("голову") списка, в то время как [tl] возвращает
    все элементы, кроме первого ("хвост").  Т.к. у пустого списка нет первого
    элемента, мы также передаём в [hd] значение по умолчанию, которое нужно
    вернуть в таком случае. *)

Definition hd (default : nat) (l : natlist) : nat :=
  match l with
  | nil => default
  | h :: t => h
  end.

Definition tl (l : natlist) : natlist :=
  match l with
  | nil => nil
  | h :: t => t
  end.

Example test_hd1:             hd 0 [1;2;3] = 1.
Proof. reflexivity. Qed.
Example test_hd2:             hd 0 [] = 0.
Proof. reflexivity. Qed.
Example test_tl:              tl [1;2;3] = [2;3].
Proof. reflexivity. Qed.

(* ----------------------------------------------------------------- *)
(** *** Упражнения *)

(** **** Упражнение: 2 звезды, стандартное, очень полезное (list_funs)

    Завершите определения [nonzeros], [oddmembers] и [countoddmembers] ниже.
    Ознакомьтесь с тестами, чтобы понять, что должны делать эти функции. *)

Fixpoint nonzeros (l:natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_nonzeros:
  nonzeros [0;1;0;2;3;0;0] = [1;2;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint oddmembers (l:natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_oddmembers:
  oddmembers [0;1;0;2;3;0;0] = [1;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Для следующей задачки, [countoddmembers], мы даём Вам заголовок,
    использующий ключевое слово [Definition] вместо [Fixpoint].
    Смысл постановки вопроса таким образом в том, чтобы замотивировать
    Вас реализовать функцию с помощью уже существующих определений
    вместо того, чтобы вновь выписывать рекурсивное определение. *)

Definition countoddmembers (l:natlist) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_countoddmembers1:
  countoddmembers [1;0;3;1;4;5] = 4.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_countoddmembers2:
  countoddmembers [0;2;4] = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_countoddmembers3:
  countoddmembers nil = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, сложное (alternate)

    Завершите определение функции [alternate], перемежающей элементы
    двух списков: [[элемент первого; элемент второго; ...]]. См. тесты
    в качестве примеров работы.

    Подсказка: есть множество естественных способов выписать [alternate],
    которые, однако, не удовлетворяют требованию Rocq, чтобы все определения
    через [Fixpoint] были _структурно рекурсивными_, как упоминалось в
    [Basics]. Если Вас это затрудняет, попробуйте сопоставлять с образцом
    сразу оба списка с помощью мультипаттерна. *)

Fixpoint alternate (l1 l2 : natlist) : natlist
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_alternate1:
  alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate2:
  alternate [1] [4;5;6] = [1;4;5;6].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate3:
  alternate [1;2;3] [4] = [1;4;2;3].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_alternate4:
  alternate [] [20;30] = [20;30].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Мультимножества на списках *)

(** Мультимножества (или бэги, [bag]) очень похожи на _множества_ за исключением
    того, что каждый элемент в мультимножестве может встречаться несколько раз.
    Один из многих способов представления мультимножества -- с помощью списка.
*)

Definition bag := natlist.

(** **** Упражнение: 3 звезды, стандартное, очень полезное (bag_functions)

    Завершите определения функций [count], [sum], [add], и [member], заданных
    на мультимножествах. *)

Fixpoint count (v : nat) (s : bag) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

(** Все утверждения должно быть можно доказать по [рефлексивности]. *)

Example test_count1:              count 1 [1;2;3;1;4;1] = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_count2:              count 6 [1;2;3;1;4;1] = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [сумма] мультимножеств похожа на объединение множеств: [sum a b]
    содержит все элементы [a] и [b].  (Математики обычно определяют
    _объединение_ мультимножеств слегка по-другому -- через взятие максимума,
    а не через сумму -- так что мы не называем нашу операцию [union] во
    избежание коллизий.)

    Мы намеренно даём Вам заголовок функции, который не именует аргументы.
    Реализуйте [sum] с помощью уже определённой функции, не меняя заголовок. *)

Definition sum : bag -> bag -> bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Definition add (v : nat) (s : bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_add1:                count 1 (add 1 [1;4;1]) = 3.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_add2:                count 5 (add 1 [1;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint member (v : nat) (s : bag) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_member1:             member 1 [1;4;1] = true.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_member2:             member 2 [1;4;1] = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное, по желанию (bag_more_functions)

    Вот ещё немного функций на мультимножествах, чтобы вы попрактиковались. *)

(** Когда [remove_one] применяется к мультимножеству, не содержащему удаляемого
    значения, она должна вернуть старое мультимножество без изменений.
    (Это упражнение опциональное; тем не менее, определение [remove_one]
    понадобится для решения более поздних дополнительных задачек.) *)

Fixpoint remove_one (v : nat) (s : bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_remove_one1:
  count 5 (remove_one 5 [2;1;5;4;1]) = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one2:
  count 5 (remove_one 5 [2;1;4;1]) = 0.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one3:
  count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_remove_one4:
  count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint remove_all (v:nat) (s:bag) : bag
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Fixpoint included (s1 : bag) (s2 : bag) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_included1:              included [1;2] [2;1;4;1] = true.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_included2:              included [1;2;2] [2;1;4;1] = false.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное, по желанию (add_inc_count)

    Добавление значения в мультимножество должно инкрементировать значение
    [count] для этого значения. Сформулируйте это утверждение в виде теоремы
    и докажите её в Rocq. *)
(*
Theorem add_inc_count : ...
Proof.
  ...
Qed.
*)

(* Не меняйте следующую строчку: *)
Definition manual_grade_for_add_inc_count : option (nat*string) := None.
(** [] *)

(* ################################################################# *)
(** * Доказательство теорем о списках *)

(** Как и в случае с числами, простые свойства функций, обрабатывающих
    списки, можно доказать только упрощениями. Например, упрощений, выполняемых
    [reflexivity], достаточно для доказательства следующей теоремы... *)

Theorem nil_app : forall l : natlist,
  [] ++ l = l.
Proof. reflexivity. Qed.

(** ...потому что [[]] подставляется в качестве "рассматриваемого"
    (выражения, которое мы "рассматриваем" в сопоставлении с образцом)
    в определении [app], в результате чего всё выражение упрощается. *)

(** Также, как было с числами, иногда полезно произвести разбор возможных
    случаев внутреннего устройства (пустой или непустой?) неизвестного списка.
*)

Theorem tl_length_pred : forall l:natlist,
  pred (length l) = length (tl l).
Proof.
  intros l. destruct l as [| n l'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons n l' *)
    reflexivity.  Qed.

(** Случай [nil] срабатывает по определению функции ([tl nil = nil]).
    Обратите внимание на аннотацию [as] в тактике [destruct]: она вводит два
    имени, [n] и [l'], ссылающихся на два аргумента конструктора [cons]
    (голову и хвост конструируемого таким образом списка). *)

(** Правда, чаще всего, доказательство интересных теорем о списках требует
    использования _индукции по спискам_.  Сейчас мы увидим, как это делать. *)

(** (Микро-наставление: с более глубоким погружением в материал, просто _чтение_
    скриптов доказательств Вам не очень поможет.  Скорее, важно именно
    рассмотреть выполнение доказательств по шагам, используя интерактивный режим
    Rocq и стараясь понять, чего достигает каждый шаг в доказательстве.
    В противном случае я гарантирую, что формулировка и решение упражнений,
    когда Вы за них приметесь, будут Вам совершенно непостижимы.) *)

(* ================================================================= *)
(** ** Индукция на списках *)

(** Доказательства по индукции на типах данных вроде [natlist], скорее
    всего, будет Вам слегка менее знакома, чем обычная (математическая) индукция
    на натуральных числах, но идея столь же проста.  Каждое [Индуктивное]
    объявление определяет множество значений, которые можно построить, используя
    объявленные конструкторы.  Например, логическое значение может быть
    либо [true], либо [false]; натуральное число может быть либо [O], либо [S],
    применённое к другому числу; наконец, список может быть
    либо [nil], либо [cons], применённый к числу и списку.  Более того,
    применения объявленных конструкторов -- это _единственные_ возможные
    способы получить элементы множества, объявленного индуктивным образом.

    Этот последний факт напрямую предоставляет способ рассуждать об индуктивно
    определяемых множествах: число -- это либо [O], либо [S], применённый к
    _меньшему_ числу; список -- это либо [nil], либо [cons], применённый к
    некоторому произвольному числу и некоторому _меньшему_ списку; и т.д..
    Таким образом, если у нас на уме некоторое утверждение [P] о списке [l], и
    мы хотим доказать, что [P] выполнено для _всех_ возможных списков [l], мы
    можем рассуждать следующим образом:

      - Во-первых, покажем, что [P] истинно для [l] в случае,
        когда [l] это [nil].

      - Далее, покажем, что [P] истинно для [l] даже в том случае, когда [l] это
        [cons n l'] для некоторого числа [n] и меньшего списка [l'],
        в предположении, что [P] истинно для [l'].

    Раз бОльшие списки всегда можно постепенным отщеплением головы уменьшить до
    [nil], два этих факта вместе позволяют установить истинность [P]
    для произвольных списков [l].

    Вот конкретный пример: *)

Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Обратите внимание, что, как было и с индукцией на натуральных числах,
    клоза [as...] в тактике [induction] позволяет именовать также
    и предположение индукции, соответствующее меньшему списку [l1'] в случае
    [cons].

    Опять же, это доказательство на Rocq не особенно восхищает, когда смотришь
    на него в статике -- проще увидеть, что происходит, если Вы читаете
    доказательство в интерактивной сессии Rocq и можете увидеть текущую цель и
    контекст на каждом шаге доказательства, которые нельзя увидеть в обычной
    записи доказательства.  Точно так же и доказательство на естественном языке
    -- написанное для чтения человеком -- должно включать более читаемые и явные
    опознавательные знаки и остановки; в особенности, мы очень поможем читателю
    ориентироваться в доказательстве, если мы будем напоминать ему, как
    в точности выглядит доказываемое утверждение в индуктивном переходе. *)

(** Для сравнения, вот неформальное (но строгое) доказательство той же самой
    теоремы. *)

(** _Теорема_: Для любых [l1], [l2] и [l3] верно, что
               [(l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)].

   _Доказательство_: Индукцией по [l1].

   - База: [l1 = []].  Нужно показать, что

       ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3),

     что верно по определению [++].

   - Переход: [l1 = n::l1'], причём по предположению индукции

       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3).

     Необходимо показать

       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

     По определению [++], это следует из

       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),

     что также верно благодаря предположению индукции.  [] *)

(* ----------------------------------------------------------------- *)
(** *** Усиление индукционной гипотезы *)

(** В некоторых случаях может быть необходимо усилить утверждение, чтобы
    его можно было доказать по индукции.  Интуитивно, причина состоит в том, что
    более сильное (более общее) утверждение также позволяет получить более
    сильное (более общее) предположение индукции.  Если Вы по каким-то причинам
    завязли в доказательстве, попробуйте отступиться, осмотреться и выяснить --
    может, внезапно получится доказать более сильное утверждение. *)

Theorem repeat_double_firsttry : forall c n: nat,
  repeat n c ++ repeat n c = repeat n (c + c).
Proof.
  intros c. induction c as [| c' IHc'].
  - (* c = 0 *)
    intros n. simpl. reflexivity.
  - (* c = S c' *)
    intros n. simpl.
    (*  Здесь-то мы, кажется, и застряли.  Мы не можем использовать IH, чтобы
        переписать [repeat n (c' + S c')]: гипотеза работает только для
        [repeat n (c' + c')]. Если бы IH была более гибкой (например, если бы
        она работала для произвольного второго слагаемого), доказательство бы
        прошло. *)
Abort.

(** Чтобы получить более сильное предположение, мы можем усилить
    утверждение следующим образом: *)

Theorem repeat_plus: forall c1 c2 n: nat,
    repeat n c1 ++ repeat n c2 = repeat n (c1 + c2).
Proof.
  intros c1 c2 n.
  induction c1 as [| c1' IHc1'].
  - simpl. reflexivity.
  - simpl.
    rewrite <- IHc1'.
    reflexivity.
  Qed.

(* ----------------------------------------------------------------- *)
(** *** Развороты списка *)

(** В качестве более сложного примера доказательств по индукции
    на списках, предположим, что мы используем [app] для определения функции
    разворота списка [rev]: *)

Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil    => nil
  | h :: t => rev t ++ [h]
  end.

Example test_rev1:            rev [1;2;3] = [3;2;1].
Proof. reflexivity.  Qed.
Example test_rev2:            rev nil = nil.
Proof. reflexivity.  Qed.

(** Возьмём задачку посложнее и попробуем доказать, что разворот списка
    не меняет его длину.  Наша первая попытка застревает на индуктивном
    переходе... *)

Theorem rev_length_firsttry : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = n :: l' *)
    (* Вот это сложный случай. Давайте, как обычно, начнём с упрощений. *)
    simpl.
    (* Кажется, мы застряли: цель -- это равенство, содержащее [++], но у нас
       пока нет никаких полезных фактов ни в локальном контексте, ни среди
       глобальных определений!  Можем попробовать немного продвинуться
       и переписать цель с помощью предположения индукции... *)
    rewrite <- IHl'.
    (* ... но дальше идти некуда. *)
Abort.

(** Можно попробовать доказать в точности то утверждение, которого нам не
    хватает на данный момент.  Но эта попытка обречена на провал, поскольку
    предположение индукции недостаточно мощное. *)
Theorem app_rev_length_S_firsttry: forall l n,
  length (rev l ++ [n]) = S (length (rev l)).
Proof.
  intros l. induction l as [| m l' IHl'].
  - (* l = [] *)
    intros n. simpl. reflexivity.
  - (* l = m:: l' *)
    intros n. simpl.
    (* IHl' применить нельзя. *)
Abort.

(** Оказывается, лемма выше гораздо слабее, чем нужно. Мы можем усилить
    лемму и работать не только с развёрнутыми списками, но с произвольными
    списками вообще. *)
Theorem app_length_S: forall l n,
  length (l ++ [n]) = S (length l).
Proof.
  intros l n. induction l as [| m l' IHl'].
  - (* l = [] *)
    simpl. reflexivity.
  - (* l = m:: l' *)
    simpl.
    rewrite IHl'.
    reflexivity.
Qed.

(** Теперь мы можем закончить основное доказательство. *)

Theorem rev_length : forall l : natlist,
  length (rev l) = length l.
Proof.
  intros l. induction l as [| n l' IHl'].
  - (* l = nil *)
    reflexivity.
  - (* l = cons *)
    simpl.
    rewrite -> app_length_S.
    rewrite -> IHl'.
    reflexivity.
Qed.

(** Обратите внимание, что лемма [app_length_S], которую мы доказали выше,
    достаточно слабая, т.к. она требует, чтобы второй список состоял из
    единственного элемента. Мы можем доказать более сильное утверждение для
    двух произвольных списков. *)
Theorem app_length : forall l1 l2 : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).
Proof.
  (* РАЗБИРАЕМ НА ЛЕКЦИИ *)
  intros l1 l2. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.

(** Для сравнения, ниже приведены неформальные доказательства этих двух теорем:

    _Теорема_: Для всяких списков [l1] и [l2] верно, что
      [length (l1 ++ l2) = length l1 + length l2].

    _Доказательство_: Индукцией по [l1].

    - База: [l1 = []].  Нам нужно показать, что

        length ([] ++ l2) = length [] + length l2,

      что напрямую следует из определений [length], [++] и [plus].

    - Переход: [l1 = n::l1']; по предположению индукции

        length (l1' ++ l2) = length l1' + length l2.

      Нам нужно показать, что

        length ((n::l1') ++ l2) = length (n::l1') + length l2.

      Это следует напрямую из определений [length] и [++], а также из
      предположения индукции. [] *)

(** _Теорема_: Для всякого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Индукцией по [l].

      - База: [l = []].  Нам нужно доказать, что

          length (rev []) = length [],

        что следует напрямую из определений [length] и [rev].

      - Шаг: [l = n::l']; по предположению индукции

          length (rev l') = length l'.

        Нам нужно показать, что

          length (rev (n :: l')) = length (n :: l').

        По определению [rev], это должно следовать из того, что

          length ((rev l') ++ [n]) = S (length l')

        что, по предыдущей лемме, эквивалентно

          length (rev l') + length [n] = S (length l').

        А это уже напрямую следует из предположения индукции
        и определения [length]. [] *)

(** Эти доказательства достаточно многословны и педантичны. После прочтения
    парочки таких доказательств, проще будет следить за доказательствами,
    разжёвывающими меньше деталей (их легко восстановить в уме, либо на бумажке,
    если необходимо) и демонстрирующими только неочевидные переходы.  В таком,
    более кратком, стиле, доказательство выше могло выглядеть следующим образом:
*)

(** _Теорема_: Для любого списка [l] верно, что [length (rev l) = length l].

    _Доказательство_: Несложной индукцией по [l] легко убедиться, что
     [length (l ++ [n]) = S (length l)] для любого [l].  Требуемое свойство же,
     в свою очередь, доказывается ещё одной индукцией по [l], где наше
     наблюдение используется в шаге индукции вместе с предположением индукции.
     [] *)

(** То, какой стиль предпочтителен в Вашей конкретной ситуации, зависит от
    предпологаемого уровня знаний Вашей аудитории и того, насколько Ваше
    доказательство похоже на те, с которыми они уже знакомы. Более педантичный
    подход для нас подходит лучше, потому что мы пытаемся излагать всё
    суперподробно. *)

(* ================================================================= *)
(** ** Команда [Search] *)

(** Мы уже убедились, что доказательства могут переиспользовать другие теоремы,
    которые мы уже доказали, например, с помощью [rewrite].  Но для того, чтобы
    сослаться на теорему, нам нужно знать её название!  Действительно, зачастую
    сложно даже вспомнить какие теоремы были доказаны, не говоря уже об их
    названиях.

    Команда [Search] с этим очень помогает.

    Допустим, Вы забыли название теоремы про [rev].  Команда [Search rev]
    запросит у Rocq список всех теорем, содержащих [rev] в формулировке. *)

Search rev.

(** Или, допустим, Вы забыли имя теоремы о коммутативности сложения. Вы можете
    использовать паттерн, чтобы поискать все теоремы, содержащие в формулировке
    равенство двух сложений. *)

Search (_ + _ = _ + _).

(** Здесь Вы увидите тучу результатов; практически все будут из стандартной
    библиотеки.  Чтобы сузить область поиска, можно искать внутри конкретного
    модуля: *)

Search (_ + _ = _ + _) inside Induction.

(** Также можно уточнить запрос, используя в паттерне переменные
    вместо вайлдкардов: *)

Search (?x + ?y = ?y + ?x).

(** (Знак вопроса перед переменной нужен, чтобы отличать переменную, объявленную
    внутри паттерна, от идентификатора из текущей области видимости.) *)

(** Не забывайте про [Search], пока выполняете упражнения курса; эта команда
    поможет вам сэкономить много-много времени!

    Кстати, Ваша среда разработки, скорее всего, имеет собственный функционал
    для помощи в поиске. Например, в VSRocq можно открыть вкладку для поиска
    с помощью сочетания клавиш [Command-Control-K]. *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 1 *)

(** **** Упражнение: 3 звезды, стандартное (list_exercises)

    Больше практики со списками: *)

Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** _Инволюция_ это функция, которая обратна сама себе. То есть, применение
    функции дважды не меняет исходное значение. *)
Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Для следующей теоремы есть краткое решение.  Если чувствуете,
    что запутались, отступитесь и попробуйте найти решение попроще. *)

Theorem app_assoc4 : forall l1 l2 l3 l4 : natlist,
  l1 ++ (l2 ++ (l3 ++ l4)) = ((l1 ++ l2) ++ l3) ++ l4.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Упражнение про Вашу реализацию [nonzeros]: *)

Lemma nonzeros_app : forall l1 l2 : natlist,
  nonzeros (l1 ++ l2) = (nonzeros l1) ++ (nonzeros l2).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звезды, стандартное (eqblist)

    Завершите определение [eqblist], функции, проверяющей списки на равенство.
    Докажите, что [eqblist l l] возвращает [true] для любого [l]. *)

Fixpoint eqblist (l1 l2 : natlist) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_eqblist1 :
  (eqblist nil nil = true).
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_eqblist2 :
  eqblist [1;2;3] [1;2;3] = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_eqblist3 :
  eqblist [1;2;3] [1;2;4] = false.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem eqblist_refl : forall l:natlist,
  true = eqblist l l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Упражнения на списки, часть 2 *)

(** Вот ещё несколько небольших теорем про мультимножества. *)

(** **** Упражнение: 1 звезда, стандартное (count_member_nonzero) *)
Theorem count_member_nonzero : forall (s : bag),
  1 <=? (count 1 (1 :: s)) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Следующая лемма о [leb] может помочь Вам в следующем упражнении
    (да и в будущем пригодится). *)

Theorem leb_n_Sn : forall n,
  n <=? (S n) = true.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* 0 *)
    simpl.  reflexivity.
  - (* S n' *)
    simpl.  rewrite IHn'.  reflexivity.  Qed.

(** Перед тем, как приступить к следующему упражнению, убедитесь, что Вы
    завершили определение [remove_one] выше. *)
(** **** Упражнение: 3 звезды, сложное (remove_does_not_increase_count) *)
Theorem remove_does_not_increase_count: forall (s : bag),
  (count 0 (remove_one 0 s)) <=? (count 0 s) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звезды, стандартное, по желанию (bag_count_sum)

    Сформулируйте ниже интересную теорему [bag_count_sum] о мультимножествах,
    связывающую функции [count] и [sum], и докажите её с помощью Rocq. (Может
    так оказаться, что сложность доказательства зависит от того, как Вы
    определили [count]!

    Подсказка: если Вы определили [count], используя [=?],
    Вам может быть полезно узнать, что [destruct] работает не только
    для переменных, но и для вообще произвольных утверждений.) *)
(* ЗАПОЛНИТЕ ЗДЕСЬ

    [] *)

(** **** Упражнение: 3 звезды, сложное (involution_injective) *)

(** Докажите, что всякая инволюция инъективна.

    Инволюции были определены выше, в [rev_involutive]. _Инъективная_
    функция же, в свою очередь, та, которая для разных аргументов возвращает
    разные значения, без коллизий. *)

Theorem involution_injective : forall (f : nat -> nat),
    (forall n : nat, n = f (f n)) -> (forall n1 n2 : nat, f n1 = f n2 -> n1 = n2).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 2 звезды, сложное (rev_injective)

    Докажите, что [rev] инъективна. Не советую доказывать по индукции --
    это будет сложно. Вместо этого переиспользуйте ту же технику, что Вы
    использовали для доказательства [involution_injective]. (Но: Не пытайтесь
    переиспользовать то упражнение как лемму: типы не сойдутся!) *)

Theorem rev_injective : forall (l1 l2 : natlist),
  rev l1 = rev l2 -> l1 = l2.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Частичные значения *)

(** Пусть мы хотим написать функцию, возвращающую [n]-й элемент некоторого
    списка.  Если мы выпишем её тип как [nat -> natlist -> nat], нам придётся
    выбрать какое-то число, чтобы возвращать его в том случае,
    если список слишком короткий... *)

Fixpoint nth_bad (l:natlist) (n:nat) : nat :=
  match l with
  | nil => 42
  | a :: l' => match n with
               | 0 => a
               | S n' => nth_bad l' n'
               end
  end.

(** Это решение не очень хорошее: если [nth_bad] возвращает [42], мы
    не сможем установить, есть ли это значение в списке, без дополнительного
    разбирательства. Альтернативой получше будет изменить тип возвращаемого
    значения в [nth_bad] таким образом, чтобы учесть значение-ошибку как
    вероятный исход запуска функции. Мы назовём этот тип [natoption]. *)

Inductive natoption : Type :=
  | Some (n : nat)
  | None.

(* Заметим, что мы написали [None] и [Some] с большой буквы, аналогично их
   названию в стандартной библиотеке Rocq.  В общем-то имена конструкторов (да и
   переменных) могут начинаться как с большой, так и с маленькой буквы. *)

(** Теперь мы можем изменить определение [nth_bad] выше так, чтобы она
    возвращала [None], когда список слишком короткий, и [Some a] в противном
    случае (и, конечно, на [n]-й позиции в списке стоит [a]). Мы назовём эту
    новую функцию [nth_error], чтобы сигнализировать о возможной ошибке. *)

Fixpoint nth_error (l:natlist) (n:nat) : natoption :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.

Example test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.
Proof. reflexivity. Qed.
Example test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.
Proof. reflexivity. Qed.
Example test_nth_error3 : nth_error [4;5;6;7] 9 = None.
Proof. reflexivity. Qed.

(** (В слайдах бойлерплейтные доказательства этих примеров опущены.
    Нажмите на бокс, если хотите увидеть доказательство.) *)

(** Функция ниже вытаскивает значение типа [nat] из [natoption], возвращая
    значение по умолчанию в случае [None]. *)

Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n' => n'
  | None => d
  end.

(** **** Упражнение: 2 звезды, стандартное (hd_error)

    Используя ту же идею, исправьте функцию [hd], определённую ранее, так, чтобы
    нам не пришлось передавать значение по умолчанию для случая [nil]. *)

Definition hd_error (l : natlist) : natoption
  (* ЗАМЕНИТЕ ЭТУ СТРОЧКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_hd_error1 : hd_error [] = None.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_hd_error2 : hd_error [1] = Some 1.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Example test_hd_error3 : hd_error [5;6] = Some 5.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** [] *)

(** **** Упражнение: 1 звезда, стандартное, по желанию (option_elim_hd)

    Это упражнение связывает вашу [hd_error] с более ранней [hd]. *)

Theorem option_elim_hd : forall (l:natlist) (default:nat),
  hd default l = option_elim default (hd_error l).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

End NatList.

(* ################################################################# *)
(** * Частичные функции *)

(** В качестве последней иллюстрации того, как можно определять типы данных в
    Rocq, ниже мы введём тип данных _частичных функций_, аналогичный
    ассоциативным массивам (aka словарям), которые легко найти в любом другом
    языке программирования. *)

(** Во-первых, определим новый индуктивный тип данных [id], который будет
    выступать в качестве "ключей" в наших словарях. *)

Inductive id : Type :=
  | Id (n : nat).

(** Внутри [id] лежит просто число.  Введение отдельного типа данных,
    оборачивающего каждое число в тэг [Id], делает определения более читаемыми
    и дарит нам гибкость в позднейшем изменении внутреннего представления [Id],
    если впоследствии нам это потребуется. *)

(** Также мы захотим проверять [id] на равенство: *)

Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | Id n1, Id n2 => n1 =? n2
  end.

(** **** Упражнение: 1 звезда, стандартное (eqb_id_refl) *)
Theorem eqb_id_refl : forall x, eqb_id x x = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Далее, определим тип частичных функций: *)

Module PartialMap.
Export NatList.  (* сделаем доступными определения из NatList *)

Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).

(** Это объявление можно прочитать так: "Есть два способа построить
    [partial_map]: либо используя конструктор [empty], чтобы представить
    пустой словарь, либо применив конструктор [record] к ключу, значению и
    существующей [partial_map], чтобы построить новую [partial_map] с
    дополнительным отображением из ключа в значение." *)

(** Функция [update] перегружает запись для данного ключа в словаре с помощью
    перекрытия старого определения новым (либо просто добавляет новую запись,
    если такого ключа ещё нет). *)

Definition update (d : partial_map)
                  (x : id) (value : nat)
                  : partial_map :=
  record x value d.

(** Наконец, функция [find] ищет в [partial_map] заданный ключ.  Она возвращает
    [None], если ключ не был найден, и [Some val], если ключ был проассоциирован
    со значением [val]. Если один и тот же ключ проассоциирован с несколькими
    значениями, [find] вернёт самое первое, которое он встретит. *)

Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty         => None
  | record y v d' => if eqb_id x y
                     then Some v
                     else find x d'
  end.

(** **** Упражнение: 1 звезда, стандартное (update_eq) *)
Theorem update_eq :
  forall (d : partial_map) (x : id) (v: nat),
    find x (update d x v) = Some v.
Proof.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда, стандартное (update_neq) *)
Theorem update_neq :
  forall (d : partial_map) (x y : id) (o: nat),
    eqb_id x y = false -> find x (update d y o) = find x d.
Proof.
 (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)
End PartialMap.

(* 2026-02-14 16:24 *)
