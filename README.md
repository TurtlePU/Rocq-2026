# Rocq 2025/26

## Добро пожаловать!

Это материалы к курсу по Rocq в Центральном Университете, основанный на
[серии электронных учебников](http://softwarefoundations.cis.upenn.edu)
о различных аспектах __Оснований ПО__, математических оснований создания
надёжного программного обеспечения. В рамках данного курса мы затронем базовые
понятия логики, доказательства теорем с помощью компьютера, использование
средства для интерактивных доказательств Rocq, функциональное программирование,
операционную семантику и техники изучения свойств программ. Знание логики и/или
теории языков программирования НЕ предполагается, однако наличие общей
математической культуры не повредит.

Отличительная особенность нашего курса (как и исходной серии книг) состоит в
том, что он на 100% формализован и проверяем машиной: все материалы курса это
буквально скрипты для Rocq. Предполагается, что слушатели изучают материал
одновременно с запуском интерактивной сессии в Rocq. Все тонкости материала
полностью формализованы в Rocq и абсолютное большинство упражнений созданы для
выполнения с помощью Coq.

В рамках данного курса на каждом из 8 занятий будет выдаваться по 1-2 файла
с расширением `.v`. В каждом из них есть как разбираемые на занятии упражнения,
так и задачи для самостоятельного решения, на основе которых будет выставлена
оценка.

__Пропустить обзор__: [тык](#onboarding).

## Обзор

Создавать надёжное ПО тяжело &mdash; ОЧЕНЬ тяжело. Масштаб и сложность
современных систем, масса привлечённых к разработке людей и набор предъявляемых
к ним требований делают затруднительным хотя бы более-менее правильную
реализацию продуктов, не говоря уже о 100%-ной корректности. Вдобавок растущая
вовлечённость обработки информации в каждый аспект общественной жизни
многократно увеличивает цену ошибок, багов и проблем с безопасностью.

По мере взросления отрасли, специалисты компьютерных наук и разработчики
придумали множество техник для улучшения надёжности программных систем,
начиная от методик управления командами разработчиков (эджайл, экстремальное
программирование и т.д.) и парадигм в разработке библиотек (например,
model-view-controller, publish-subscribe, и т.д.) и языков программирования
(ООП, функциональное программирование, ...) до математических техник для
формального задания (спецификации) свойств программ, а также инструментов,
помогающих в проверке этих свойств. В рамках данного курса мы сосредоточимся
на последней категории.

Первая половина курса связывает собой следующие темы:

1. базовые инструменты из __логики__ для формулировки и доказательства
   математически точных утверждений о программах;

2. использование __ассистентов в формальных доказательствах__ (__proof
   assistants__) для конструирования строгих логических аргументов;

3. __функциональное программирование__, и как методику программирования,
   которая упрощает рассуждения о программах,
   и как мост между программированием и логикой.

### Логика

Логика &mdash; это область исследований, предметом которых являются
__доказательства__ &mdash; неопровержимые аргументы в пользу истинности
конкретных утверждений. О центральной роли логики в компьютерных науках написаны
тонны книг; Манна и Уолдингер назвали это "математическим анализом компьютерных
наук", в то время как статья Халперна и др. __Эффективность логики в
компьютерных науках__ описывает множество способов, с помощью которых логика
предлагает важнейшие инструменты и идеи для анализа программ и алгоритмов.
Действительно, они отмечают, что "На самом деле логика оказалась значительно
более эффективной в компьютерных науках, чем в математике. Это весьма
примечательно, особенно с учетом того, что за последние сто лет математика во
многом придала импульс развитию логики."

В частности, фундаментальные инструменты __индуктивных доказательств__ широко
распространены во всех областях компьютерных наук. Вы наверняка видели их
раньше, возможно, в курсе дискретной математики или анализа алгоритмов,
но в этом курсе мы рассмотрим их более подробно чем вы, вероятно,
делали это до сих пор.

### Инструменты интерактивного доказательства теорем

Обмен идеями между логикой и информатикой не был однонаправленным: CS также
привнесли много нового в логику. В частности, было разработано множество
программных средств, помогающих создавать доказательства логических утверждений.
Эти инструменты делятся на две большие категории:

- __Aвтоматизированные средства доказательства теорем__ обеспечивают "кнопочное"
  управление: вы даете им предложение, и они возвращают либо __ИСТИНА__, либо
  __ЛОЖЬ__ (или, иногда, __НЕ ЗНАЮ: НЕ ХВАТИЛО ВРЕМЕНИ__). Хотя их возможности
  к рассуждениям по-прежнему ограничены, за последние десятилетия они
  значительно усовершенствовались и в настоящее время используются во множестве
  ситуаций. Примеры таких инструментов включают в себя SAT-решатели, SMT-солверы
  и средства проверки моделей.

- __Инструменты интерактивного доказательства теорем__ (proof assistants)
  &mdash; это гибридные инструменты, автоматизирующие более рутинные аспекты
  создания доказательств, но которые в то же время направляются человеком
  в более сложных аспектах. Широко используемые ассистенты включают в себя
  Isabelle, Agda, Twelf, ACL2, PVS, F*, HOL4, Lean, Rocq и многие другие.

Этот курс основан на Rocq, proof assistant-е, который разрабатывается
с 1983 года и который в последние годы привлёк большое сообщество пользователей
как в научных кругах, так и в индустрии. Rocq предоставляет богатую среду для
интерактивной разработки формальных рассуждений, проверяемых машиной. Ядро
системы Rocq &mdash; это простая программа проверки правильности доказательства,
которая гарантирует, что все шаги в логическом рассуждении корректны.
В дополнение к этому ядру среда Rocq предоставляет высокоуровневые средства для
разработки доказательств, включая большую библиотеку общих определений и лемм,
мощные __тактики__ построения сложных доказательств полуавтоматически,
и специальный язык программирования для определения новых тактик
для автоматизации доказательств в специфичных ситуациях.

Rocq стал ключевым стимулирующим фактором для огромного разнообразия работ по
компьютерным наукам и математике:

- В качестве __платформы для моделирования языков программирования__, он стал
  стандартным инструментом для исследователей, которым необходимо описывать
  объёмные определения языков и исследовать их свойства. Например, он
  использовался для проверки безопасности платформы Java Card, для формальных
  спецификаций набора инструкций x86 и LLVM, языков программирования (того же C).

- В качестве __среды для разработки формально сертифицированного программного
  и аппаратного обеспечения__, Rocq использовался, например, для создания
  CompCert, полностью верифицированного оптимизирующего компилятора для C,
  и CertiKOS, полностью верифицированного гипервизора, для проверки корректности
  тонких мест в алгоритмах, использующих вычисления c плавающей запятой,
  и является основой для CertiCrypt, FCF и SS Prove, фреймворков для проверки
  безопасности криптографических алгоритмов. Он также используется для создания
  верифицированных реализаций архитектуры процессора RISC-V
  с открытым исходным кодом.

- В качестве __реалистичной среды для функционального программирования с
  зависимыми типами__, он вдохновил многочисленные инновации. Например, Хоарова
  теория типов позволяет рассуждать о "предварительных условиях" и
  "постусловиях" (расширение __логики Хоара__) в Rocq.

- В качестве __proof assistant-a для логики высшего порядка__, Rocq был
  использован для проверки ряда важных результатов в математике. Например, его
  способность производить сложные вычисления по ходу доказательства позволила
  разработать первое формально верифицированное доказательство Теоремы о четырёх
  красках. Принятие не-верифицированной версии этого доказательства ранее было
  спорным вопросом среди математиков, потому что она требовала компьютерного
  перебора большого количества вариантов. В свою очередь, в формализации на Rocq
  проверяется всё, в том числе и правильность произведённых вычислений. Совсем
  недавно были предприняты еще более масштабные усилия, приведшие к формализации
  на Rocq теоремы Фейта-Томпсона, первого важного шага в классификации
  конечных простых групп.

### Функциональное программирование

Термин __функциональное программирование__ применяется как к набору идиом
программирования, которые могут быть использованы практически в любом языке
программирования, так и к семейству языков программирования, разработанных с
учетом этих идиом, включающему Haskell, OCaml, Standard ML, F#, Scala, Scheme,
Racket, Common Lisp, Clojure, Erlang, F* и Coq.

Функциональное программирование разрабатывалось на протяжении многих десятилетий
&mdash; его корни уходят в лямбда-исчисление Чёрча, которое было изобретено
в 1930-х годах, задолго до появления первых электронных компьютеров! Но с начала
90-х годов он вызвал всплеск интереса среди промышленных инженеров
и разработчиков языков программирования, сыграв ключевую роль в высокоприбыльных
системах в таких компаниях, как Jane Street Capital, Microsoft, Facebook,
Twitter и Ericsson.

Самый основной принцип функционального программирования заключается в том,
что вычисления, насколько это возможно, должны быть __чистыми__ в том смысле,
что единственным эффектом исполнения должно быть получение результата в виде
данных: в нём не должно быть __сайд-эффектов__, таких как ввод-вывод, присвоения
значений изменяемым переменным, перенаправления указателей и т.д. Например, в то
время как __императивная__ функция сортировки может взять список чисел
и переставить его указатели, чтобы упорядочить список, чистая функция сортировки
возьмет исходный список и вернет __новый__ список, содержащий те же числа
в отсортированном порядке.

Существенным преимуществом этого стиля программирования является то, что он
облегчает понимание программы и рассуждение о её свойствах. Если каждая операция
со структурой данных приводит к созданию новой структуры данных, оставляя старую
структуру неизменной, то нет необходимости беспокоиться о том, как эта структура
используется совместно и может ли изменение в одной части программы нарушить
инвариант, на который опирается другая часть программы. Эти соображения особенно
важны в конкурентных системах, где каждая часть изменяемого состояния, доступная
из нескольких потоков, является потенциальным источником опасных ошибок.
Действительно, большая часть современного интереса к применению функционального
программирования в промышленности обусловлено его более простым поведением
при наличии параллелизма.

Еще одна причина нынешнего ажиотажа по поводу функционального программирования
связана с первой: функциональные программы часто гораздо проще распараллеливать
и физически распространять, чем их императивные аналоги. Если запуск вычислений
не дает никакого эффекта кроме получения конкретного значения, неважно, __где__
эти вычисления запускать. Аналогично, если к структуре данных никогда не
применяется разрушающее изменение, её можно свободно копировать между ядрами
или по сети. Идиома "Map-Reduce", которая лежит в основе обработчиков массово
распределённых запросов вроде Hadoop и используется в Google для индексации
всего Интернета, является классическим примером функционального программирования.

Для целей данного курса функциональное программирование имеет еще одну важную
черту: оно служит связующим звеном между логикой и компьютерными науками.
Действительно, Rocq сам по себе можно рассматривать как сочетание небольшого,
но чрезвычайно выразительного функционального языка программирования плюс набор
инструментов для формулирования и доказательства логических утверждений.
Более того, при более внимательном рассмотрении мы обнаружим, что эти две
стороны Coq на самом деле являются аспектами одного и того же базового механизма
&mdash; другими словами, __доказательства &mdash; это программы__.

### Rocq и Coq

До 2025, Rocq был ранее известен как Coq. Вот что написано на официальном
веб-сайте по этому поводу: "Имя 'Coq' отсылалось к Исчислению Конструкций
(Calculus of Constructions, CoC), фундаментальной системе, на которой основан
прувер, а также к имени одного из своих создателей, Тьерри Коканда (Thierry
Coquand). Вдобавок, оно служило оммажем к национальному символу франции, петуху.
Новое имя, 'the Rocq Prover', посвящено коммуне Рокканкур (INRIA Rocquencourt),
месту, где началась разработка прувера. Также в нём слышна аллюзия на мифическую
птицу Рух (Roc, Rukh), символизирующую силу (и являющуюся не очень-то далёкой
родственницей петуха). Вдобавок, имя передаёт ощущение твёрдости, а неожиданная
коннотация с музыкальным жанром добавляет приятного резонанса."

Тем не менее, переименование ещё в процессе, так что то и дело Вам будет
попадаться старое название: в документации, названиях утилит, старых вопросах
на форумах...

### Рекомендованная и дополнительная литература

Этот курс задуман как самостоятельный, но слушатели, которые хотят глубже
разобраться в отдельных темах, найдут некоторые рекомендации для дальнейшего
чтения в главе TBA. Библиографию всех цитируемых работ можно найти в файле TBA.

## Onboarding

### Системные требования

Rocq работает на Windows, Linux, и macOS. Материалы этого курса были
протестированы на версии Rocq 9.0.0.

Вам потребуется:

- Свежая версия Rocq, доступная на
  [домашней странице Rocq](https://rocq-prover.org/install). "Coq Platform",
  как правило, установить проще всего, особенно на Windows.

  Если Вы используете комбинацию VSCode + Docker, описанную ниже, Вам
  не потребуется устанавливать Rocq отдельно.

- IDE для взаимодействия с Rocq.  Есть несколько вариантов:

  - __VsCoq__ &mdash; это расширение для VS Code, предлагающее простой интерфейс
    в знакомой IDE. Это "рекомендованный по умолчанию" вариант.
    VsCoq может быть использован как обычная IDE, либо может быть совмещён
    с Docker (см. ниже).

  - __Proof General__ &mdash; это IDE, основанная на Emacs. Обычно, её
    предпочитают пользователи, которым уже привычен Emacs. Он требует отдельной
    установки и настройки (загуглите "Proof General", но, как правило, всё, что
    Вам нужно сделать, это `M-x package-list-packages`, затем выбрать пакет
    `proof-general` из списка и нажать `i` для установки, затем `x`
    для исполнения).
    Для уверенного использования ProofGeneral достаточно знания всего нескольких
    команд. Вот они:
    - `C-c C-n`: ввести текущую команду в Rocq.
    - `C-c C-u`: отменить последний ввод.
    - `C-c C-RET`: ввести все команды до текущей включительно в Rocq.
    - `C-c C-.`: переместить курсор к месту последней обработанной Rocq команды.
    - `C-c .`: переключиться в "режим заряженной точки". Когда этот режим
      включён, простой ввод символа `.` отправит текущую команду в Rocq (обычно
      после ввода точки нужно ещё прожимать комбинацию `C-c C-n`).
    Желающим поэкспериментировать с Rocq внутри Emacs могут понравиться такие
    расширения как `company-coq` и `control-lock`.

  - __RocqIDE__ &mdash; это упрощённая самостоятельная IDE. Она распространяется
    вместе с Rocq Platform, так что должна быть доступна сразу, как Вы
    установите Rocq. Также её можно собрать из исходников, но на некоторых
    платформах это может потребовать установки дополнительных пакетов
    для GUI-фреймворков и пр.
    Пользователям, которым нравится RocqIDE, стоит попробовать запустить его
    с выключенными режимами "asynchronous" и "error resilience":

      coqide -async-proofs off \
             -async-proofs-command-error-resilience off Foo.v &

  - Ваш покорный слуга предпочитает использовать __NeoVim__ с плагином
    __Coqtail__ для построчного режима либо __coq-lsp.nvim__ для LSP-режима.

### Rocq на VSCode + Docker

VS Code может взаимодействовать с платформой виртуализации Docker для компиляции
скриптов на Rocq без необходимости какой-либо отдельной установки Rocq. Данный
способ установки указан в новых версиях оригинального учебника
как рекомендованный для большинства пользователей. Однако имейте в виду,
что данный способ требует загрузки большого объёма данных из Интернета, а также
будет работать чуть медленнее из-за виртуализации программы внутри Docker.

- [Установите Docker](https://www.docker.com/get-started/) или убедитесь,
  что у Вашей текущей установки актуальная версия.

- Убедитесь, что Docker запущен.

- [Установите VS Code](https://code.visualstudio.com) и запустите его.

- Установите расширение
  [Remote Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)
  для VS Code. (Обратите внимание, что это расширение работает только
  с официальной версией VSCode, но не с форками вроде VsCodium)

- Склонируйте к себе репозиторий курса (в VS Code это можно сделать, выбрав
  опцию "Clone Git Repository..."). Помимо файла `.v` для каждой главы, этот
  репозиторий будет содержать подпапку `.devcontainer` с инструкциями
  для VSCode о том, где найти соответствующий образ Docker и файл
  `_CoqProject`, наличие которого является триггером для запуска VsCoq.

- Откройте репозиторий в VS Code. IDE должна спросить вас, хотите ли вы
  запустить проект в соответствующем контейнере Docker. (Если вас не спросят, вы
  можете открыть палитру команд, нажав клавишу F1, и выполнить команду
  “Dev Containers: Reopen in Container”.) Возможно, это займёт какое-то время.

- Убедитесь, что VSCoq работает, дважды щелкнув файл `Basics.v` в списке слева
  (вы должны увидеть мигающий курсор в открывшемся окне; если нет, вы можете
  щелкнуть на этом окне, чтобы выбрать его), и несколько раз нажмите
  `alt+стрелка вниз` (в Mac OS &mdash; `control+option+стрелка вниз`). Вы должны
  увидеть, как курсор перемещается по файлу, а область над курсором становится
  подсвеченной.

- Если VSCoq не работает, а Вы получаете сообщение об ошибке, что `vscoqtop`
  не найден: откройте новое окошко терминала в контейнере (для этого можно
  открыть палитру команд и запустить команду "Terminal: Create New Terminal")
  и запустите команду `which vscoqtop`. Она должна распечатать путь к месту
  установки VSCoq внутри контейнера. Скопируйте этот путь и вставьте его в
  текстовое поле "VSCoq: Path" в настройках расширения VSCoq (доступно
  при нажатии на иконку шестерёнки на странице расширения VSCoq в VSCode),
  а затем перезапустите окно.

- Чтобы узнать, какие ещё сочетания клавиш доступны, нажмите клавишу F1 и затем
  введите `Coq:` или посетите
  [веб-страницу VSCoq](https://github.com/rocq-prover/vsrocq).

## Упражнения

Каждая глава содержит множество упражнений. Каждое из них отмечено "звездным
рейтингом", который можно интерпретировать следующим образом:

- Одна звездочка: простые упражнения, которые подчеркивают некоторые моменты
  в тексте и которые для большинства слушателей должны занять всего минуту
  или две. Возьмите за привычку выполнять их по мере чтения.

- Две звезды: простые упражнения (пять-десять минут).

- Три звезды: упражнения, требующие некоторого размышления (от десяти минут
  до получаса).

- Четыре и пять звезд: более сложные упражнения (дольше получаса).

Имейте в виду, что автогрейдер присваивает дополнительные баллы за более сложные
упражнения:

| # звёздочек | # баллов  |
| ----------- | --------- |
| 1 звездочка | 1 балл    |
| 2 звездочки | 2 балла   |
| 3 звездочки | 3 балла   |
| 4 звездочки | 6 баллов  |
| 5 звездочек | 10 баллов |

Некоторые упражнения помечены как "продвинутые", а некоторые &mdash; как
"необязательные". Выполнение только обязательных, не-продвинутых упражнений
должно обеспечивать хорошее усвоение базового материала. Необязательные
упражнения дают немного дополнительной практики в работе с ключевыми понятиями
и знакомят с второстепенными темами, которые могут представлять интерес
для некоторых слушателей. Продвинутые упражнения предназначены для слушателей,
которым нужен дополнительный челлендж и более глубокое погружение.

__Пожалуйста, не размещайте решения упражнений в публичном доступе__.
Оригинальная серия книг, Software Foundations, широко используется
как для самостоятельного изучения, так и для университетских курсов. Наличие
легкодоступных решений делает его гораздо менее полезным для курсов, которые
обычно содержат домашние задания с оценкой. Мы особенно просим слушателей
не размещать решения к упражнениям в тех местах,
где их могут найти поисковые системы.

## Загрузка файлов Rocq

Архив с расширением `.tar`, содержащий все исходники к "публичному релизу"
оригинальной книги (в виде коллекции скриптов на Coq и файлов HTML) доступен
[по ссылке](https://softwarefoundations.cis.upenn.edu).

Наши слегка отредактированные и переведённые на русский язык файлы доступны
в [репозитории курса](https://github.com/TurtlePU/Rocq-2026). По ходу
прохождения курса, в нём будут появляться новые материалы каждую неделю.

## Ресурсы

### Лекционные видео

Лекции по двум летним интенсивам, основанным на оригинальной книге __Logical
Foundations__ (входит в программу регулярной летней школы DeepSpec; первая
половина нашего курса) можно найти [по следующим](https://deepspec.org/event/dsss17)
[ссылкам](https://deepspec.org/event/dsss18). Качество видео в лекциях за 2017
поначалу не очень хорошее, но в дальнейшем становится гораздо лучше.

Также во внутренней системе ЦУ, как обычно, будут доступны записи всех занятий.

--------------------------------------------------------------------------------

Исходный текст сгенерирован 2026-02-08 в 01:52.
